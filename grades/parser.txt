=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
//empty program

===[good0.bminor Output]===
Success!

Program parsed successfully.


return code: 0


===[good1.bminor Input]===
// variables in and out of fxns
x:integer = 5;
y:integer;
z:char = 'A';
fxn: function void () =
{
	x:integer;
	y:integer = 16;
	w:boolean = true;
	q:boolean;
}

===[good1.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     z
DEFINE         :
CHAR           char
ASSIGN         =
CHAR LITERAL   'A' A
SEMICOLON      ;
IDENTIFIER     fxn
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    16
SEMICOLON      ;
IDENTIFIER     w
DEFINE         :
BOOL           boolean
ASSIGN         =
TRUE           true
SEMICOLON      ;
IDENTIFIER     q
DEFINE         :
BOOL           boolean
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good10.bminor Input]===
//some variable usages
x:integer;
y:integer;
z:integer;
arr:array[5] array[5] integer;
str: string = "hello world";
fxn : function  integer () =
{
	arr[3][2] = 5;
	x = arr[2][3];
	x++;
	return z;
	c:char = str[0];
} 

===[good10.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     z
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     arr
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    5
RIGHT BRACKET  ]
ARRAY          array
LEFT BRACKET   [
INT LITERAL    5
RIGHT BRACKET  ]
INT            integer
SEMICOLON      ;
IDENTIFIER     str
DEFINE         :
STRING         string
ASSIGN         =
STRING LITERAL hello world
SEMICOLON      ;
IDENTIFIER     fxn
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     arr
LEFT BRACKET   [
INT LITERAL    3
RIGHT BRACKET  ]
LEFT BRACKET   [
INT LITERAL    2
RIGHT BRACKET  ]
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     x
ASSIGN         =
IDENTIFIER     arr
LEFT BRACKET   [
INT LITERAL    2
RIGHT BRACKET  ]
LEFT BRACKET   [
INT LITERAL    3
RIGHT BRACKET  ]
SEMICOLON      ;
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RETURN         return
IDENTIFIER     z
SEMICOLON      ;
IDENTIFIER     c
DEFINE         :
CHAR           char
ASSIGN         =
IDENTIFIER     str
LEFT BRACKET   [
INT LITERAL    0
RIGHT BRACKET  ]
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good3.bminor Input]===
// produces correct precedence of operations

main: function void () = {
	x:integer = 5;
	y:integer = 4;
	if(true || false && true)
	{
		x = 6;
		
	}
}

===[good3.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    4
SEMICOLON      ;
IF             if
LEFT PAREN     (
TRUE           true
OR             ||
FALSE          false
AND            &&
TRUE           true
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
ASSIGN         =
INT LITERAL    6
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good4.bminor Input]===
// produces correct precedence of operations

main: function void() = {
	x:integer = 5;
	y:integer = 4;
	if(!((4*x^5 + 4) - 4 >= 1))
	{
		x = 6;
		
	}
}

===[good4.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    4
SEMICOLON      ;
IF             if
LEFT PAREN     (
NOT            !
LEFT PAREN     (
LEFT PAREN     (
INT LITERAL    4
MULTIPLY       *
IDENTIFIER     x
EXPONENT       ^
INT LITERAL    5
ADD            +
INT LITERAL    4
RIGHT PAREN    )
NEGATIVE       -
INT LITERAL    4
GEQ            >=
INT LITERAL    1
RIGHT PAREN    )
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
ASSIGN         =
INT LITERAL    6
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good5.bminor Input]===
// produces correct precedence of operations

main: function void() = {
	x:integer = 5;
	y:integer = 4;
	z:boolean  = true || -(4*x^5) + (4 - 4) >= 16 - 6 * 3 + x && y^2 == 16;
}

===[good5.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    4
SEMICOLON      ;
IDENTIFIER     z
DEFINE         :
BOOL           boolean
ASSIGN         =
TRUE           true
OR             ||
NEGATIVE       -
LEFT PAREN     (
INT LITERAL    4
MULTIPLY       *
IDENTIFIER     x
EXPONENT       ^
INT LITERAL    5
RIGHT PAREN    )
ADD            +
LEFT PAREN     (
INT LITERAL    4
NEGATIVE       -
INT LITERAL    4
RIGHT PAREN    )
GEQ            >=
INT LITERAL    16
NEGATIVE       -
INT LITERAL    6
MULTIPLY       *
INT LITERAL    3
ADD            +
IDENTIFIER     x
AND            &&
IDENTIFIER     y
EXPONENT       ^
INT LITERAL    2
EQUALITY       ==
INT LITERAL    16
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good6.bminor Input]===
// test block creations
x:integer;
main:function void() = {
	for(;;)
	{
		x:integer = 5;
		{
			x:integer = 6;
			print x;
		}
	}

	if(x > 5)
	{
		x++;
	}
}
funct2: function void() = {
	{
		print "hello";
	}
	if(x > 5)
		if(x < 5)
		{
			x++;
		}
	else
	{
		x++;
		x--;
	}		
	
}

===[good6.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
FOR            for
LEFT PAREN     (
SEMICOLON      ;
SEMICOLON      ;
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    6
SEMICOLON      ;
PRINT          print
IDENTIFIER     x
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
IDENTIFIER     funct2
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
LEFT BRACE     {
PRINT          print
STRING LITERAL hello
SEMICOLON      ;
RIGHT BRACE    }
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
RIGHT PAREN    )
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    5
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
IDENTIFIER     x
DECREMENT      --
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good7.bminor Input]===
// test block creations
x:integer;
main:function void() = {
	for(;;)
	{
		x:integer = 5;
		{
			x:integer = 6;
			print x;
		}
	}

	if(x > 5)
	{
		x++;
	}
}
funct2: function void() = {
	{
		print "hello";
	}
	if(x > 5)
		if(x < 5)
		{
			x++;
		}
	else
	{
		x++;
		x--;
	}		
	
}

===[good7.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
FOR            for
LEFT PAREN     (
SEMICOLON      ;
SEMICOLON      ;
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    6
SEMICOLON      ;
PRINT          print
IDENTIFIER     x
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
IDENTIFIER     funct2
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
LEFT BRACE     {
PRINT          print
STRING LITERAL hello
SEMICOLON      ;
RIGHT BRACE    }
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
RIGHT PAREN    )
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    5
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
IDENTIFIER     x
DECREMENT      --
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good8.bminor Input]===
//solved if else works

main: function void() = {
	x:integer = 5;
	if( 4 < 5 )
		if( 10 < 20 )
			for(x = 0; x < 5; x++)
				if( 4 < 5 )
					print "helloo\n";
				else
					print "hello\n";
		else
			print "goodbye";
}

===[good8.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IF             if
LEFT PAREN     (
INT LITERAL    4
LESS THAN      <
INT LITERAL    5
RIGHT PAREN    )
IF             if
LEFT PAREN     (
INT LITERAL    10
LESS THAN      <
INT LITERAL    20
RIGHT PAREN    )
FOR            for
LEFT PAREN     (
IDENTIFIER     x
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     x
LESS THAN      <
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     x
INCREMENT      ++
RIGHT PAREN    )
IF             if
LEFT PAREN     (
INT LITERAL    4
LESS THAN      <
INT LITERAL    5
RIGHT PAREN    )
PRINT          print
STRING LITERAL helloo

SEMICOLON      ;
ELSE           else
PRINT          print
STRING LITERAL hello

SEMICOLON      ;
ELSE           else
PRINT          print
STRING LITERAL goodbye
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good9.bminor Input]===
//tests param lists
fxn: function integer (x:integer)=
{
	return x++;
}

fxn2: function char (x:integer, y:char, z:boolean) =
{
}

fxn3: function char (x: array [] integer, y:char, z: array [] array [] boolean)=
{
}


===[good9.bminor Output]===
Success!

IDENTIFIER     fxn
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RETURN         return
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     fxn2
DEFINE         :
FOR            function
CHAR           char
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
CHAR           char
COMMA          ,
IDENTIFIER     z
DEFINE         :
BOOL           boolean
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RIGHT BRACE    }
IDENTIFIER     fxn3
DEFINE         :
FOR            function
CHAR           char
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
CHAR           char
COMMA          ,
IDENTIFIER     z
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
BOOL           boolean
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RIGHT BRACE    }
Program parsed successfully.


return code: 0


====Bad Tests====
===[bad0.bminor Input]===
// semicolon isn't a statement
fxn:function void() =
{
	;
}

===[bad0.bminor Output]===
Success!

IDENTIFIER     fxn
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad1.bminor Input]===
// can't use anything but print in this form
printf "hello world", x, y;

===[bad1.bminor Output]===
Success!

IDENTIFIER     printf
STRING LITERAL hello world
COMMA          ,
IDENTIFIER     x
COMMA          ,
IDENTIFIER     y
SEMICOLON      ;
parse error: syntax error


return code: 1


===[bad10.bminor Input]===
// test function without closing brace
x:integer = 6;
fxn:function void() =
{
	integer= 5; 
	
	
}

===[bad10.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    6
SEMICOLON      ;
IDENTIFIER     fxn
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad2.bminor Input]===
// for loop without correct # of args
main:function void()=
{
	for(i=0; i++) {
		print i;
	}
}

===[bad2.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     i
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad3.bminor Input]===
//print not seperated by ,'s
x:intger = 5;
main:function void()
{
	print x x "hello";
}

===[bad3.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
IDENTIFIER     intger
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     x
IDENTIFIER     x
STRING LITERAL hello
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad4.bminor Input]===
// expressions must end with ;
x:integer = 5;

main:function void()=
{
	x++;
	x++
}

===[bad4.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
IDENTIFIER     x
INCREMENT      ++
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad5.bminor Input]===
// if must be matched
x:integer = 5;
main:function void()=
{
	x++;
	if(x > 5)
}

===[bad5.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
RIGHT PAREN    )
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad6.bminor Input]===
//checking param lists with trailing ,
main:function void(hello:string, )=
{
	print hello;
}

===[bad6.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     hello
DEFINE         :
STRING         string
COMMA          ,
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
PRINT          print
IDENTIFIER     hello
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad7.bminor Input]===
// if must be matched
x:integer = 5;
main:function void()=
{
	x++;
	if(x > 5)
}

===[bad7.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
RIGHT PAREN    )
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad8.bminor Input]===
// test else without a if to match it
x:integer;
funct2: function void() = {
			if(x < 5)
			{
				x++;
			}
			else
			{
				x++;
				x--;
			}
		 
	else 
	{
		print "error, this shouldn't work";
	}
			
	
}

===[bad8.bminor Output]===
Success!

IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     funct2
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    5
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
IDENTIFIER     x
INCREMENT      ++
SEMICOLON      ;
IDENTIFIER     x
DECREMENT      --
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
PRINT          print
STRING LITERAL error, this shouldn't work
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad9.bminor Input]===
// test function calls with wrong format in calls

main: function void () =
{
	print x;
	func3(4 y, z);
}

===[bad9.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
PRINT          print
IDENTIFIER     x
SEMICOLON      ;
IDENTIFIER     func3
LEFT PAREN     (
INT LITERAL    4
IDENTIFIER     y
COMMA          ,
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
/* A program is a sequence of declarations */
/* Try a variety of variable declarations. */

n: integer;
m: integer = 20;

b: boolean;
c: boolean = true;
s: string;
t: string = "hello\n";
d: char;
e: char = 'x';

x: array [] string;
y: array [] string = { "a", "b", "c" };
z: array [] array [] string = { {"a","b","c"}, {"x","y","z"} };

g: array [3] string;
h: array [3] string = { "a", "b", "c" };
i: array [2] array [3] string = { {"a","b","c"}, {"x","y","z"} };

===[good1.bminor Output]===
TEST NOT PASSED

IDENTIFIER     n
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     m
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    20
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
BOOL           boolean
SEMICOLON      ;
IDENTIFIER     c
DEFINE         :
BOOL           boolean
ASSIGN         =
TRUE           true
SEMICOLON      ;
IDENTIFIER     s
DEFINE         :
STRING         string
SEMICOLON      ;
IDENTIFIER     t
DEFINE         :
STRING         string
ASSIGN         =
STRING LITERAL hello

SEMICOLON      ;
IDENTIFIER     d
DEFINE         :
CHAR           char
SEMICOLON      ;
IDENTIFIER     e
DEFINE         :
CHAR           char
ASSIGN         =
CHAR LITERAL   'x' x
SEMICOLON      ;
IDENTIFIER     x
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
ASSIGN         =
LEFT BRACE     {
STRING LITERAL a
COMMA          ,
STRING LITERAL b
COMMA          ,
STRING LITERAL c
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     z
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
ASSIGN         =
LEFT BRACE     {
LEFT BRACE     {
STRING LITERAL a
COMMA          ,
STRING LITERAL b
COMMA          ,
STRING LITERAL c
RIGHT BRACE    }
COMMA          ,
LEFT BRACE     {
STRING LITERAL x
COMMA          ,
STRING LITERAL y
COMMA          ,
STRING LITERAL z
RIGHT BRACE    }
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     g
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    3
RIGHT BRACKET  ]
STRING         string
SEMICOLON      ;
IDENTIFIER     h
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    3
RIGHT BRACKET  ]
STRING         string
ASSIGN         =
LEFT BRACE     {
STRING LITERAL a
COMMA          ,
STRING LITERAL b
COMMA          ,
STRING LITERAL c
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     i
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    2
RIGHT BRACKET  ]
ARRAY          array
LEFT BRACKET   [
INT LITERAL    3
RIGHT BRACKET  ]
STRING         string
ASSIGN         =
LEFT BRACE     {
LEFT BRACE     {
STRING LITERAL a
COMMA          ,
STRING LITERAL b
COMMA          ,
STRING LITERAL c
RIGHT BRACE    }
COMMA          ,
LEFT BRACE     {
STRING LITERAL x
COMMA          ,
STRING LITERAL y
COMMA          ,
STRING LITERAL z
RIGHT BRACE    }
RIGHT BRACE    }
SEMICOLON      ;
parse error: syntax error


return code: 1


===[good10.bminor Input]===
/* Try accesssing arrays of various sizes; */

a: array [10] integer = {100,200,300,400,500,600,700,800,900};
b: array [10] integer;
c: array [10] array [10] integer;

testfunc: function void () = {
    i: integer;
    j: integer;

    for(i=0;i<10;i++) {
        b[i] = a[i] * 10;
    }

    for(i=0;i<5;i++) {
        b[i*2] = a[i] + b[i];
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            c[i][j] = i*j;
        }
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            print c[i][j];
            print " ";
        }
        print "\n";
    }
}

===[good10.bminor Output]===
Success!

IDENTIFIER     a
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
INT            integer
ASSIGN         =
LEFT BRACE     {
INT LITERAL    100
COMMA          ,
INT LITERAL    200
COMMA          ,
INT LITERAL    300
COMMA          ,
INT LITERAL    400
COMMA          ,
INT LITERAL    500
COMMA          ,
INT LITERAL    600
COMMA          ,
INT LITERAL    700
COMMA          ,
INT LITERAL    800
COMMA          ,
INT LITERAL    900
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
INT            integer
SEMICOLON      ;
IDENTIFIER     c
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
ARRAY          array
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
INT            integer
SEMICOLON      ;
IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     j
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     b
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
ASSIGN         =
IDENTIFIER     a
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
MULTIPLY       *
INT LITERAL    10
SEMICOLON      ;
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     b
LEFT BRACKET   [
IDENTIFIER     i
MULTIPLY       *
INT LITERAL    2
RIGHT BRACKET  ]
ASSIGN         =
IDENTIFIER     a
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
ADD            +
IDENTIFIER     b
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
SEMICOLON      ;
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
IDENTIFIER     j
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     j
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     c
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
LEFT BRACKET   [
IDENTIFIER     j
RIGHT BRACKET  ]
ASSIGN         =
IDENTIFIER     i
MULTIPLY       *
IDENTIFIER     j
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
IDENTIFIER     j
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     j
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     c
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
LEFT BRACKET   [
IDENTIFIER     j
RIGHT BRACKET  ]
SEMICOLON      ;
PRINT          print
STRING LITERAL  
SEMICOLON      ;
RIGHT BRACE    }
PRINT          print
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good11.bminor Input]===

/* Try locally declared array lengths */


testfunc: function void (x: integer, y: integer) = {
    i: integer;
    j: integer;

    a: array [10] integer = {100,200,300,400,500,600,700,800,900};
    b: array [x] integer;
    c: array [x] array [y] integer;

    for(i=0;i<10;i++) {
        b[i] = a[i] * 10;
    }

    for(i=0;i<5;i++) {
        b[i*2] = a[i] + b[i];
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            c[i][j] = i*j;
        }
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            print c[i][j];
            print " ";
        }
        print "\n";
    }
}

===[good11.bminor Output]===
Success!

IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     j
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     a
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
INT            integer
ASSIGN         =
LEFT BRACE     {
INT LITERAL    100
COMMA          ,
INT LITERAL    200
COMMA          ,
INT LITERAL    300
COMMA          ,
INT LITERAL    400
COMMA          ,
INT LITERAL    500
COMMA          ,
INT LITERAL    600
COMMA          ,
INT LITERAL    700
COMMA          ,
INT LITERAL    800
COMMA          ,
INT LITERAL    900
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
ARRAY          array
LEFT BRACKET   [
IDENTIFIER     x
RIGHT BRACKET  ]
INT            integer
SEMICOLON      ;
IDENTIFIER     c
DEFINE         :
ARRAY          array
LEFT BRACKET   [
IDENTIFIER     x
RIGHT BRACKET  ]
ARRAY          array
LEFT BRACKET   [
IDENTIFIER     y
RIGHT BRACKET  ]
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     b
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
ASSIGN         =
IDENTIFIER     a
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
MULTIPLY       *
INT LITERAL    10
SEMICOLON      ;
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     b
LEFT BRACKET   [
IDENTIFIER     i
MULTIPLY       *
INT LITERAL    2
RIGHT BRACKET  ]
ASSIGN         =
IDENTIFIER     a
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
ADD            +
IDENTIFIER     b
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
SEMICOLON      ;
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
IDENTIFIER     j
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     j
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     c
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
LEFT BRACKET   [
IDENTIFIER     j
RIGHT BRACKET  ]
ASSIGN         =
IDENTIFIER     i
MULTIPLY       *
IDENTIFIER     j
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
IDENTIFIER     j
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     j
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     c
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
LEFT BRACKET   [
IDENTIFIER     j
RIGHT BRACKET  ]
SEMICOLON      ;
PRINT          print
STRING LITERAL  
SEMICOLON      ;
RIGHT BRACE    }
PRINT          print
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good12.bminor Input]===

/* single statement ifs */

x: integer = 65;
s: string = "hello";
b: boolean = false;

min: function integer ( a: integer, b: integer ) =
{
	if(a > b) return a;
	else return b;
}

testfunc: function void ( z: integer ) =
{
	print "minimum", min(10, 5), "\n";
}

===[good12.bminor Output]===
TEST NOT PASSED

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    65
SEMICOLON      ;
IDENTIFIER     s
DEFINE         :
STRING         string
ASSIGN         =
STRING LITERAL hello
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
BOOL           boolean
ASSIGN         =
FALSE          false
SEMICOLON      ;
IDENTIFIER     min
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     a
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     b
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     a
GREATER THAN   >
IDENTIFIER     b
RIGHT PAREN    )
RETURN         return
IDENTIFIER     a
SEMICOLON      ;
ELSE           else
RETURN         return
IDENTIFIER     b
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     z
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
PRINT          print
STRING LITERAL minimum
COMMA          ,
IDENTIFIER     min
LEFT PAREN     (
INT LITERAL    10
COMMA          ,
INT LITERAL    5
RIGHT PAREN    )
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[good13.bminor Input]===
/* string format expr */

x: integer = 65;
s: string = "hello";
b: boolean = false;

min: function integer ( a: integer, b: integer ) =
{
	if(a > b) return a;
	else return b;
}

testfunc: function void ( z: integer ) =
{
	print "minimum", min(10, 5), "\n", z=10, z==10;
}
	

===[good13.bminor Output]===
TEST NOT PASSED

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    65
SEMICOLON      ;
IDENTIFIER     s
DEFINE         :
STRING         string
ASSIGN         =
STRING LITERAL hello
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
BOOL           boolean
ASSIGN         =
FALSE          false
SEMICOLON      ;
IDENTIFIER     min
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     a
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     b
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     a
GREATER THAN   >
IDENTIFIER     b
RIGHT PAREN    )
RETURN         return
IDENTIFIER     a
SEMICOLON      ;
ELSE           else
RETURN         return
IDENTIFIER     b
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     z
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
PRINT          print
STRING LITERAL minimum
COMMA          ,
IDENTIFIER     min
LEFT PAREN     (
INT LITERAL    10
COMMA          ,
INT LITERAL    5
RIGHT PAREN    )
COMMA          ,
STRING LITERAL 

COMMA          ,
IDENTIFIER     z
ASSIGN         =
INT LITERAL    10
COMMA          ,
IDENTIFIER     z
EQUALITY       ==
INT LITERAL    10
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[good14.bminor Input]===

/* returning various expressions */

testfunc: function void ( x: integer, y:integer, z:integer ) = {
	return x;
	return "hello";
	return x = 10;
	return x == 10;
	return x > 5;
	return testfunc(x, y, z);
}

===[good14.bminor Output]===
Success!

IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     z
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RETURN         return
IDENTIFIER     x
SEMICOLON      ;
RETURN         return
STRING LITERAL hello
SEMICOLON      ;
RETURN         return
IDENTIFIER     x
ASSIGN         =
INT LITERAL    10
SEMICOLON      ;
RETURN         return
IDENTIFIER     x
EQUALITY       ==
INT LITERAL    10
SEMICOLON      ;
RETURN         return
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
SEMICOLON      ;
RETURN         return
IDENTIFIER     testfunc
LEFT PAREN     (
IDENTIFIER     x
COMMA          ,
IDENTIFIER     y
COMMA          ,
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good15.bminor Input]===


/* code blocks */

testfunc: function void ( x: integer, y:integer, z:integer ) = {
	{
		return x;
		return "hello";
		return x = 10;
	}
	{
		return x == 10;
		{
			return x > 5;
			return testfunc(x, y, z);
		}
	}
}

===[good15.bminor Output]===
Success!

IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     z
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
LEFT BRACE     {
RETURN         return
IDENTIFIER     x
SEMICOLON      ;
RETURN         return
STRING LITERAL hello
SEMICOLON      ;
RETURN         return
IDENTIFIER     x
ASSIGN         =
INT LITERAL    10
SEMICOLON      ;
RIGHT BRACE    }
LEFT BRACE     {
RETURN         return
IDENTIFIER     x
EQUALITY       ==
INT LITERAL    10
SEMICOLON      ;
LEFT BRACE     {
RETURN         return
IDENTIFIER     x
GREATER THAN   >
INT LITERAL    5
SEMICOLON      ;
RETURN         return
IDENTIFIER     testfunc
LEFT PAREN     (
IDENTIFIER     x
COMMA          ,
IDENTIFIER     y
COMMA          ,
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good2.bminor Input]===
/* Function prototypes are declarations without bodies. */

ComputeAscii: function char ( c: char );

GetLength: function integer ( s: string, i: integer );

/* Function body has some code in it */

GetArea: function integer ( width: integer, height: integer ) =
{
	return width * height;
}

===[good2.bminor Output]===
Success!

IDENTIFIER     ComputeAscii
DEFINE         :
FOR            function
CHAR           char
LEFT PAREN     (
IDENTIFIER     c
DEFINE         :
CHAR           char
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     GetLength
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     s
DEFINE         :
STRING         string
COMMA          ,
IDENTIFIER     i
DEFINE         :
INT            integer
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     GetArea
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     width
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     height
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RETURN         return
IDENTIFIER     width
MULTIPLY       *
IDENTIFIER     height
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good3.bminor Input]===
/* A function contains a sequence of statements */
/* Some of those statements can be decls */

simplefunc: function void () = {
     x: integer;
     y: integer = 20;
     s: string = "hello world";
}

===[good3.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    20
SEMICOLON      ;
IDENTIFIER     s
DEFINE         :
STRING         string
ASSIGN         =
STRING LITERAL hello world
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good4.bminor Input]===
/* A function contains a sequence of statements */
/* Try decls and stmts and exprs together. */

simplefunc: function boolean ( x: integer, y: integer ) = {

     // A declaration
     z: integer = x * y;

     // An expression with a semicolon
     z = 16 + x / y;

     // Print statement
     print "input is: ", x, " and ", y, "\n";

     // Simple if-else statement
     if( x < y ) {
         return true;
     } else {
         return false;
     }

}

===[good4.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
BOOL           boolean
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     z
DEFINE         :
INT            integer
ASSIGN         =
IDENTIFIER     x
MULTIPLY       *
IDENTIFIER     y
SEMICOLON      ;
IDENTIFIER     z
ASSIGN         =
INT LITERAL    16
ADD            +
IDENTIFIER     x
DIVISION       /
IDENTIFIER     y
SEMICOLON      ;
PRINT          print
STRING LITERAL input is: 
COMMA          ,
IDENTIFIER     x
COMMA          ,
STRING LITERAL  and 
COMMA          ,
IDENTIFIER     y
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
IDENTIFIER     y
RIGHT PAREN    )
LEFT BRACE     {
RETURN         return
TRUE           true
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
RETURN         return
FALSE          false
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good5.bminor Input]===
/* A function contains a sequence of statements */
/* Try decls and stmts and exprs together. */
/* Add some float */

simplefunc: function boolean ( x: integer, y: integer ) = {

     // A declaration
     z: integer = x * y;
	
     // A float declaration
     q: float = 10e9;
     
     // another float
     v: float = 2.10e2;

     // a float operation
     return v;

}

===[good5.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
BOOL           boolean
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     z
DEFINE         :
INT            integer
ASSIGN         =
IDENTIFIER     x
MULTIPLY       *
IDENTIFIER     y
SEMICOLON      ;
IDENTIFIER     q
DEFINE         :
FLOAT          float
ASSIGN         =
FLOAT LITERAL  10000000000.000000
SEMICOLON      ;
IDENTIFIER     v
DEFINE         :
FLOAT          float
ASSIGN         =
FLOAT LITERAL  210.000000
SEMICOLON      ;
RETURN         return
IDENTIFIER     v
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good6.bminor Input]===
/* Try several variations of for-loops */

simplefunc: function void (r: integer, s: integer, t: integer ) = {

    i: integer;

    for( i=0; i<r; i++ ) {
        print i,"\n";
    }

    i=0;
    for( ; i<s; i++ ) {
        print i,"\n";
    }

    i=0;
    for( ; i<r; ) {
        print i,"\n";
        i++;
    }

    for(;;) print "forever!\n";
}

===[good6.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     r
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     s
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     t
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     r
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     i
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
FOR            for
LEFT PAREN     (
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     s
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     i
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
FOR            for
LEFT PAREN     (
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     r
SEMICOLON      ;
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     i
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
SEMICOLON      ;
RIGHT BRACE    }
FOR            for
LEFT PAREN     (
SEMICOLON      ;
SEMICOLON      ;
RIGHT PAREN    )
PRINT          print
STRING LITERAL forever!

SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good7.bminor Input]===
/* Test various nestings of if-else statements */

testit: function boolean ( x: integer, y: integer ) = {

	/* If statement without braces */
	if( x<y ) print "less\n"; else print "low\n";

	/* If statement with braces */
	if( x<y ) { print "less\n"; } else { print "low\n"; }

	/* This statement should print nothing */
        if(20<10) if(10<20) print "incorrect!"; else print "dangling else!";

	/* statements and decls inside of if-else */

        if( x>y ) {
              i: integer;
              for(i=0;i<x;i++) print i, "\n";
        } else {
              i: integer;
              for(i=0;i<y;i++) print i, "\n";
        }

	/* A decl can come after a few statements */
	i: integer;

	/* try the other way around */
	for(i=0;i<x;i++) {
              if( i<x ) print "small"; else print "large";
        }

        return true;
}

===[good7.bminor Output]===
Success!

IDENTIFIER     testit
DEFINE         :
FOR            function
BOOL           boolean
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
IDENTIFIER     y
RIGHT PAREN    )
PRINT          print
STRING LITERAL less

SEMICOLON      ;
ELSE           else
PRINT          print
STRING LITERAL low

SEMICOLON      ;
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
IDENTIFIER     y
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
STRING LITERAL less

SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
PRINT          print
STRING LITERAL low

SEMICOLON      ;
RIGHT BRACE    }
IF             if
LEFT PAREN     (
INT LITERAL    20
LESS THAN      <
INT LITERAL    10
RIGHT PAREN    )
IF             if
LEFT PAREN     (
INT LITERAL    10
LESS THAN      <
INT LITERAL    20
RIGHT PAREN    )
PRINT          print
STRING LITERAL incorrect!
SEMICOLON      ;
ELSE           else
PRINT          print
STRING LITERAL dangling else!
SEMICOLON      ;
IF             if
LEFT PAREN     (
IDENTIFIER     x
GREATER THAN   >
IDENTIFIER     y
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     x
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
PRINT          print
IDENTIFIER     i
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     y
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
PRINT          print
IDENTIFIER     i
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     x
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     x
RIGHT PAREN    )
PRINT          print
STRING LITERAL small
SEMICOLON      ;
ELSE           else
PRINT          print
STRING LITERAL large
SEMICOLON      ;
RIGHT BRACE    }
RETURN         return
TRUE           true
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[good8.bminor Input]===
/* Now try some expressions */

x: integer = 65;
s: string = "hello";
b: boolean = false;

min: function integer ( a: integer, b: integer ) =
{
	if( a<b ) return a; else return b;
}

testfunc: function void ( z: integer ) =
{
	// Nested integer operators.
	y: integer = x*(x*10 + 55%6 + z/10);
	print "y: ", y, "\n";

	// Nested boolean operations.
	c: boolean = ( x<100 && y>200 ) || !(b=true);
	print "c: ", c, "\n";

	// Boolean operations on strings?
	d: boolean = (s == "goodbye");
	print "d: ", d, "\n";

	// Can we stack up assignments?
	z = y = x;

	a: array [100] integer;

	// Function calls and array accesses:
	y = min(a[10],a[20]);
}

===[good8.bminor Output]===
TEST NOT PASSED

IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    65
SEMICOLON      ;
IDENTIFIER     s
DEFINE         :
STRING         string
ASSIGN         =
STRING LITERAL hello
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
BOOL           boolean
ASSIGN         =
FALSE          false
SEMICOLON      ;
IDENTIFIER     min
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     a
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     b
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     a
LESS THAN      <
IDENTIFIER     b
RIGHT PAREN    )
RETURN         return
IDENTIFIER     a
SEMICOLON      ;
ELSE           else
RETURN         return
IDENTIFIER     b
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     z
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
IDENTIFIER     x
MULTIPLY       *
LEFT PAREN     (
IDENTIFIER     x
MULTIPLY       *
INT LITERAL    10
ADD            +
INT LITERAL    55
MODULO         %
INT LITERAL    6
ADD            +
IDENTIFIER     z
DIVISION       /
INT LITERAL    10
RIGHT PAREN    )
SEMICOLON      ;
PRINT          print
STRING LITERAL y: 
COMMA          ,
IDENTIFIER     y
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
IDENTIFIER     c
DEFINE         :
BOOL           boolean
ASSIGN         =
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    100
AND            &&
IDENTIFIER     y
GREATER THAN   >
INT LITERAL    200
RIGHT PAREN    )
OR             ||
NOT            !
LEFT PAREN     (
IDENTIFIER     b
ASSIGN         =
TRUE           true
RIGHT PAREN    )
SEMICOLON      ;
PRINT          print
STRING LITERAL c: 
COMMA          ,
IDENTIFIER     c
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
IDENTIFIER     d
DEFINE         :
BOOL           boolean
ASSIGN         =
LEFT PAREN     (
IDENTIFIER     s
EQUALITY       ==
STRING LITERAL goodbye
RIGHT PAREN    )
SEMICOLON      ;
PRINT          print
STRING LITERAL d: 
COMMA          ,
IDENTIFIER     d
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
IDENTIFIER     z
ASSIGN         =
IDENTIFIER     y
ASSIGN         =
IDENTIFIER     x
SEMICOLON      ;
IDENTIFIER     a
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    100
RIGHT BRACKET  ]
INT            integer
SEMICOLON      ;
IDENTIFIER     y
ASSIGN         =
IDENTIFIER     min
LEFT PAREN     (
IDENTIFIER     a
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
COMMA          ,
IDENTIFIER     a
LEFT BRACKET   [
INT LITERAL    20
RIGHT BRACKET  ]
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[good9.bminor Input]===
/* Check for minimum use of parentheses. */

testfunc: function void ( x: integer, y:integer, z:integer ) = {

          r: integer;
	  b: boolean;

          // Parens required
	  r = (x+y)/z;
	  r = x+(y+z);
	  b = (true||false) && (false||true);

          // Parens not required
	  r = x+(y/z);
	  r = (x+y)+z;
	  b = (x+y) < (x+z);
	  b = (true&&false) || (false&&true);

}

===[good9.bminor Output]===
Success!

IDENTIFIER     testfunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     y
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     z
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     r
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     b
DEFINE         :
BOOL           boolean
SEMICOLON      ;
IDENTIFIER     r
ASSIGN         =
LEFT PAREN     (
IDENTIFIER     x
ADD            +
IDENTIFIER     y
RIGHT PAREN    )
DIVISION       /
IDENTIFIER     z
SEMICOLON      ;
IDENTIFIER     r
ASSIGN         =
IDENTIFIER     x
ADD            +
LEFT PAREN     (
IDENTIFIER     y
ADD            +
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     b
ASSIGN         =
LEFT PAREN     (
TRUE           true
OR             ||
FALSE          false
RIGHT PAREN    )
AND            &&
LEFT PAREN     (
FALSE          false
OR             ||
TRUE           true
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     r
ASSIGN         =
IDENTIFIER     x
ADD            +
LEFT PAREN     (
IDENTIFIER     y
DIVISION       /
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     r
ASSIGN         =
LEFT PAREN     (
IDENTIFIER     x
ADD            +
IDENTIFIER     y
RIGHT PAREN    )
ADD            +
IDENTIFIER     z
SEMICOLON      ;
IDENTIFIER     b
ASSIGN         =
LEFT PAREN     (
IDENTIFIER     x
ADD            +
IDENTIFIER     y
RIGHT PAREN    )
LESS THAN      <
LEFT PAREN     (
IDENTIFIER     x
ADD            +
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     b
ASSIGN         =
LEFT PAREN     (
TRUE           true
AND            &&
FALSE          false
RIGHT PAREN    )
OR             ||
LEFT PAREN     (
FALSE          false
AND            &&
TRUE           true
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


====Bad Tests====
===[bad1.bminor Input]===
/* A program is a not an expression at the top level */

x = 5;


===[bad1.bminor Output]===
Success!

IDENTIFIER     x
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
parse error: syntax error


return code: 1


===[bad10.bminor Input]===
/* Unbalanced braces */

main:function integer ( x: integer ) =
{
	if(x<10) {
              if(x!=23) {
                  print "hello";
              } else {
                  print "goodbye";
              }
        print "too few braces";
}

===[bad10.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    10
RIGHT PAREN    )
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     x
INEQUALITY     !=
INT LITERAL    23
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
STRING LITERAL hello
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
PRINT          print
STRING LITERAL goodbye
SEMICOLON      ;
RIGHT BRACE    }
PRINT          print
STRING LITERAL too few braces
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad11.bminor Input]===
/* return return */

simplefunc: function void () = {
     x: integer = 10;
     y: integer = 20;

     return return;

}

===[bad11.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    20
SEMICOLON      ;
RETURN         return
RETURN         return
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad12.bminor Input]===
/* invalid keyword usage */

simplefunc: function void () = {
     x: integer = 10;
     array: integer = 20;

     return x + array;
}

===[bad12.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    10
SEMICOLON      ;
ARRAY          array
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    20
SEMICOLON      ;
RETURN         return
IDENTIFIER     x
ADD            +
ARRAY          array
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad13.bminor Input]===

/* empty array initializer */

simplefunc: function void () = {
     x: integer = 10;
     y: integer = 20;
	
     p: array [5] integer = {};
}

===[bad13.bminor Output]===
TEST NOT PASSED

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    20
SEMICOLON      ;
IDENTIFIER     p
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    5
RIGHT BRACKET  ]
INT            integer
ASSIGN         =
LEFT BRACE     {
RIGHT BRACE    }
SEMICOLON      ;
RIGHT BRACE    }
Program parsed successfully.


return code: 0


===[bad14.bminor Input]===

/* Array declaration attempt */


simplefunc: function void () = {
	c7: array [x] char = {'C', 'E', 'G', "Bb"};
	d7: array [c7;] char = c7 + 1; 
}

===[bad14.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     c7
DEFINE         :
ARRAY          array
LEFT BRACKET   [
IDENTIFIER     x
RIGHT BRACKET  ]
CHAR           char
ASSIGN         =
LEFT BRACE     {
CHAR LITERAL   'C' C
COMMA          ,
CHAR LITERAL   'E' E
COMMA          ,
CHAR LITERAL   'G' G
COMMA          ,
STRING LITERAL Bb
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     d7
DEFINE         :
ARRAY          array
LEFT BRACKET   [
IDENTIFIER     c7
SEMICOLON      ;
RIGHT BRACKET  ]
CHAR           char
ASSIGN         =
IDENTIFIER     c7
ADD            +
INT LITERAL    1
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad15.bminor Input]===
/* empty file? */


===[bad15.bminor Output]===

Program parsed successfully.


return code: 0


===[bad2.bminor Input]===
/* A program is a not a sequence of statements */

print "hello world";
return 5;

===[bad2.bminor Output]===
Success!

PRINT          print
STRING LITERAL hello world
SEMICOLON      ;
RETURN         return
INT LITERAL    5
SEMICOLON      ;
parse error: syntax error


return code: 1


===[bad3.bminor Input]===
/* Cannot have more elses than ifs */

simplefunc: function void () = {
     x: integer = 10;
     y: integer = 20;

     if(x<y) if(y>x) else print "a"; else print "b" else print "c";
}

===[bad3.bminor Output]===
Success!

IDENTIFIER     simplefunc
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    10
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    20
SEMICOLON      ;
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
IDENTIFIER     y
RIGHT PAREN    )
IF             if
LEFT PAREN     (
IDENTIFIER     y
GREATER THAN   >
IDENTIFIER     x
RIGHT PAREN    )
ELSE           else
PRINT          print
STRING LITERAL a
SEMICOLON      ;
ELSE           else
PRINT          print
STRING LITERAL b
ELSE           else
PRINT          print
STRING LITERAL c
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad4.bminor Input]===
/* For loop does need to have semis even if parts are missing */

main: function void() =
{
        i: integer;
	for(i=0;) print i;
}

===[bad4.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
RIGHT PAREN    )
PRINT          print
IDENTIFIER     i
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad5.bminor Input]===
/* Print statement must separate elemnts with a comma */

main:function void()
{
	print x y z;
}

===[bad5.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     x
IDENTIFIER     y
IDENTIFIER     z
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad6.bminor Input]===
/* Function parameters must separate with a comma */

main:function void( x:integer y:integer );

===[bad6.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
IDENTIFIER     y
DEFINE         :
INT            integer
RIGHT PAREN    )
SEMICOLON      ;
parse error: syntax error


return code: 1


===[bad7.bminor Input]===
/* No invalid seqeuences of operators */

main:function integer ( x:integer ) = {

        return x + * 5 * - 7;
}

===[bad7.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RETURN         return
IDENTIFIER     x
ADD            +
MULTIPLY       *
INT LITERAL    5
MULTIPLY       *
NEGATIVE       -
INT LITERAL    7
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad8.bminor Input]===
/* Unbalanced parentheses */

main:function integer( x: integer ) =
{
	return (x*(x+5);
}

===[bad8.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RETURN         return
LEFT PAREN     (
IDENTIFIER     x
MULTIPLY       *
LEFT PAREN     (
IDENTIFIER     x
ADD            +
INT LITERAL    5
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===[bad9.bminor Input]===
/* Unbalanced braces */

main:function integer ( x: integer ) =
{
	if(x<10) {
              if(x!=23) {
                  print "hello";
              } else {
                  print "goodbye";
              }
        }

    }
    print "too many braces";
}

===[bad9.bminor Output]===
Success!

IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    10
RIGHT PAREN    )
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     x
INEQUALITY     !=
INT LITERAL    23
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
STRING LITERAL hello
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
PRINT          print
STRING LITERAL goodbye
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
RIGHT BRACE    }
PRINT          print
STRING LITERAL too many braces
SEMICOLON      ;
RIGHT BRACE    }
parse error: syntax error


return code: 1


===== SUMMARIZED PARSER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 10,
      "incorrect": 0
    },
    "Bad": {
      "correct": 11,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 11,
      "incorrect": 4
    },
    "Bad": {
      "correct": 13,
      "incorrect": 2
    }
  }
}

Parser Project Grade
-------------------

General Structure: 19/25
---------------------------------
Grammar structure is going to have issues with 
order of operations. There is a small expression
example in the book that can get you started on that. Page 71.

Scanner tokens should not be printed out during parsing.

Eliminating Ambiguities: 10/10
--------------------------------------
No conflicts reported

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 30/35
---------------------------
Fails 5 hidden tests, see above. 

Code Style: 10/10
------------------------
code is well organized

Total: 89/100
------------------------------------------
