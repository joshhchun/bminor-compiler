=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
// Test simple addition (var add and raw add)

main: function integer () = {
    x: integer = 3 + 2;
    y: integer = 5;

    print "should be 5: ", x, " ", "should be 10: ", x+y, "\n";
    if (x+y != 10) return 0;
    return 0;
}

===[good0.bminor Output]===
.file "jchun2-compiler/test/codegen/good0.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $3, %rbx
MOVQ $2, %r10
ADDQ %rbx, %r10
MOVQ %r10, -8(%rbp)
MOVQ $5, %rbx
MOVQ %rbx, -16(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 5: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " "
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L3:
.string "should be 10: "
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string "\n"
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
ADDQ %rbx, %r10
MOVQ $10, %rbx
CMP %rbx, %r10
JNE .L7
MOVQ $0, %rbx
JMP .L8
.L7:
MOVQ $1, %rbx
.L8:
CMP $0, %rbx
JE .L5
MOVQ $0, %r10
MOVQ %r10, %rax
JMP main_end
JMP .L6
.L5:
.L6:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 5: 5 should be 10: 10


return code: 0


===[good1.bminor Input]===
// Test subtraction

main: function integer () = {
	x: integer = 10;
	y: integer = x - 5;
	z: integer = y - 1 - 1 - 1 - 1;

	print "should be 5: ", y, " should be 1: ", z, " should be 0: ", z-1, "\n";

	if (x != 10 || y != 5 || z != 1) {
		print "error..\n";
		return 1;
	} else {
		return 0;
	}
}
===[good1.bminor Output]===
.file "jchun2-compiler/test/codegen/good1.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $10, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ $5, %r10
SUBQ %r10, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ %rbx, -24(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 5: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " should be 1: "
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L3:
.string " should be 0: "
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string "\n"
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $10, %r10
CMP %r10, %rbx
JNE .L7
MOVQ $0, %r10
JMP .L8
.L7:
MOVQ $1, %r10
.L8:
MOVQ -16(%rbp), %rbx
MOVQ $5, %r11
CMP %r11, %rbx
JNE .L9
MOVQ $0, %r11
JMP .L10
.L9:
MOVQ $1, %r11
.L10:
CMPQ $1, %r10
JE .L11
CMPQ $1, %r10
JE .L11
MOVQ $0, %r11
JMP .L12
.L11:
MOVQ $1, %r11
.L12:
MOVQ -24(%rbp), %rbx
MOVQ $1, %r10
CMP %r10, %rbx
JNE .L13
MOVQ $0, %r10
JMP .L14
.L13:
MOVQ $1, %r10
.L14:
CMPQ $1, %r11
JE .L15
CMPQ $1, %r11
JE .L15
MOVQ $0, %r10
JMP .L16
.L15:
MOVQ $1, %r10
.L16:
CMP $0, %r10
JE .L5
PUSHQ %rdi
.data
.L17:
.string "error..\n"
.text
LEAQ .L17(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L6
.L5:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
.L6:
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 5: 5 should be 1: 1 should be 0: 0


return code: 0


===[good10.bminor Input]===
// loops

x:integer=5;
main: function integer () = {
	// Uses a complex expression
	y:integer = 2;
	z: integer = (x + 10) * y - x*4;
	if (z != 10) {
		print "error..\n";
		return 1;
	}
	return 0;
}

===[good10.bminor Output]===
.file "jchun2-compiler/test/codegen/good10.bminor"
.data
x:
.quad 5
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $2, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ x, %rbx
MOVQ $10, %r10
ADDQ %rbx, %r10
MOVQ -8(%rbp), %rbx
MOVQ %r10, %rax
IMUL %rbx
MOVQ %rax, %rbx
MOVQ x, %r10
MOVQ $4, %r11
MOVQ %r10, %rax
IMUL %r11
MOVQ %rax, %r11
SUBQ %r11, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ $10, %r10
CMP %r10, %rbx
JNE .L3
MOVQ $0, %r10
JMP .L4
.L3:
MOVQ $1, %r10
.L4:
CMP $0, %r10
JE .L1
PUSHQ %rdi
.data
.L5:
.string "error..\n"
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L2
.L1:
.L2:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 0


===[good11.bminor Input]===
// tests comparisions/if statements with chars
c:char = 'c';
main: function integer () =
{
	a:char = 'a';
	cdup:char = 'c';
	
	if(c == cdup )
	{
		print "should be printed\n";
	}
	else {
		print "shouldn't be printed\n";
		return 1;
	}
	
	if(c != a )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
		return 1;
	}


	//switched now (statement should be false)
	if(c != cdup )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	
	if(c == a )
	{
		print "shouldn't be printed\n";
		return 1;
	}
	else
	{
		print "should be printed\n";
	}
	return 0;
}

===[good11.bminor Output]===
.file "jchun2-compiler/test/codegen/good11.bminor"
.data
c:
.quad 99
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $97, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $99, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ c, %rbx
MOVQ -16(%rbp), %r10
CMP %r10, %rbx
JE .L3
MOVQ $0, %r10
JMP .L4
.L3:
MOVQ $1, %r10
.L4:
CMP $0, %r10
JE .L1
PUSHQ %rdi
.data
.L5:
.string "should be printed\n"
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L2
.L1:
PUSHQ %rdi
.data
.L6:
.string "shouldn't be printed\n"
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
.L2:
MOVQ c, %rbx
MOVQ -8(%rbp), %r10
CMP %r10, %rbx
JNE .L9
MOVQ $0, %r10
JMP .L10
.L9:
MOVQ $1, %r10
.L10:
CMP $0, %r10
JE .L7
PUSHQ %rdi
.data
.L11:
.string "should be printed\n"
.text
LEAQ .L11(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L8
.L7:
PUSHQ %rdi
.data
.L12:
.string "shouldn't be printed\n"
.text
LEAQ .L12(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
.L8:
MOVQ c, %rbx
MOVQ -16(%rbp), %r10
CMP %r10, %rbx
JNE .L15
MOVQ $0, %r10
JMP .L16
.L15:
MOVQ $1, %r10
.L16:
CMP $0, %r10
JE .L13
PUSHQ %rdi
.data
.L17:
.string "shouldn't be printed\n"
.text
LEAQ .L17(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L14
.L13:
PUSHQ %rdi
.data
.L18:
.string "should be printed\n"
.text
LEAQ .L18(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.L14:
MOVQ c, %rbx
MOVQ -8(%rbp), %r10
CMP %r10, %rbx
JE .L21
MOVQ $0, %r10
JMP .L22
.L21:
MOVQ $1, %r10
.L22:
CMP $0, %r10
JE .L19
PUSHQ %rdi
.data
.L23:
.string "shouldn't be printed\n"
.text
LEAQ .L23(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L20
.L19:
PUSHQ %rdi
.data
.L24:
.string "should be printed\n"
.text
LEAQ .L24(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.L20:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be printed
should be printed
should be printed
should be printed


return code: 0


===[good12.bminor Input]===
// tests strings/string assignments and printing 
str:string = "hello";
main:function integer () =
{
	print str;
	str2:string = " world";
	print str2;
    
    return 0;
}
===[good12.bminor Output]===
.file "jchun2-compiler/test/codegen/good12.bminor"
.data
str:
.string "hello"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
LEAQ str(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.data
.L1:
.string " world"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

hello world

return code: 0


===[good13.bminor Input]===
// tests strings and string comparisions
// and use of strings as local variables

str:string = "hello";
str2:string = " world";

main:function integer () =
{
	str3:string = str;
	if(str == str3)
	{
		print str;
	}
	else
	{
		print "shouldn't be printed";
        return 1;
	}
	if(str != str2)
	{
		print str2;
	}
	else
	{
		print "shouldn't be printed";
        return 1;
	}
    return 0;
}
===[good13.bminor Output]===
.file "jchun2-compiler/test/codegen/good13.bminor"
.data
str:
.string "hello"
.data
str2:
.string " world"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
LEAQ str(%rip), %rbx
MOVQ %rbx, -8(%rbp)
LEAQ str(%rip), %rbx
MOVQ -8(%rbp), %r10
CMP %r10, %rbx
JE .L3
MOVQ $0, %r10
JMP .L4
.L3:
MOVQ $1, %r10
.L4:
CMP $0, %r10
JE .L1
PUSHQ %rdi
LEAQ str(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L2
.L1:
PUSHQ %rdi
.data
.L5:
.string "shouldn't be printed"
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
.L2:
LEAQ str(%rip), %rbx
LEAQ str2(%rip), %r10
CMP %r10, %rbx
JNE .L8
MOVQ $0, %r10
JMP .L9
.L8:
MOVQ $1, %r10
.L9:
CMP $0, %r10
JE .L6
PUSHQ %rdi
LEAQ str2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L7
.L6:
PUSHQ %rdi
.data
.L10:
.string "shouldn't be printed"
.text
LEAQ .L10(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
.L7:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

hello world

return code: 0


===[good14.bminor Input]===
// more str comparisons
main: function integer () = {
	x: string = "hello";
	y: string = x;

    if (x == y) print "same!\n";
    else{
        print "not same..!\n";
        return 1;
    }

    z: string = "ok";
    if (x == z) print "same!\n";
    else print "not same..!\n";
    l: string = "hello";
    if (x == l) print "same!\n";
    else print "not same..!\n";
    return 0;
}
===[good14.bminor Output]===
.file "jchun2-compiler/test/codegen/good14.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $32, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
.data
.L1:
.string "hello"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
CMP %r10, %rbx
JE .L4
MOVQ $0, %r10
JMP .L5
.L4:
MOVQ $1, %r10
.L5:
CMP $0, %r10
JE .L2
PUSHQ %rdi
.data
.L6:
.string "same!\n"
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L3
.L2:
PUSHQ %rdi
.data
.L7:
.string "not same..!\n"
.text
LEAQ .L7(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
.L3:
.data
.L8:
.string "ok"
.text
LEAQ .L8(%rip), %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -24(%rbp), %r10
CMP %r10, %rbx
JE .L11
MOVQ $0, %r10
JMP .L12
.L11:
MOVQ $1, %r10
.L12:
CMP $0, %r10
JE .L9
PUSHQ %rdi
.data
.L13:
.string "same!\n"
.text
LEAQ .L13(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L10
.L9:
PUSHQ %rdi
.data
.L14:
.string "not same..!\n"
.text
LEAQ .L14(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.L10:
.data
.L15:
.string "hello"
.text
LEAQ .L15(%rip), %rbx
MOVQ %rbx, -32(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -32(%rbp), %r10
CMP %r10, %rbx
JE .L18
MOVQ $0, %r10
JMP .L19
.L18:
MOVQ $1, %r10
.L19:
CMP $0, %r10
JE .L16
PUSHQ %rdi
.data
.L20:
.string "same!\n"
.text
LEAQ .L20(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
JMP .L17
.L16:
PUSHQ %rdi
.data
.L21:
.string "not same..!\n"
.text
LEAQ .L21(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.L17:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

same!
not same..!
not same..!


return code: 0


===[good15.bminor Input]===
// returning strings
foo: function string () = {
    return "hello";
}

main: function integer () = {
    print foo(), " world\n";
    return 0;
}
===[good15.bminor Output]===
.file "jchun2-compiler/test/codegen/good15.bminor"
.text
.global foo
foo:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
.data
.L1:
.string "hello"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rax
JMP foo_end
foo_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " world\n"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

hello world


return code: 0


===[good16.bminor Input]===
// blocks and complicated expr
y: integer = 10;
main: function integer () = {
    l: integer = 3;
    x: integer = 2;
    z: integer = ((2^10) * 16) + (5^l)*y;
    print z, "\n";
    if (z != 17634) {
        print "error...\n";
        return 1;
    }
    return 0;
}
===[good16.bminor Output]===
.file "jchun2-compiler/test/codegen/good16.bminor"
.data
y:
.quad 10
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $3, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $2, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ $2, %rbx
MOVQ $10, %r10
PUSHQ %rdi
PUSHQ %rsi
MOVQ %rbx, %rdi
MOVQ %r10, %rsi
CALL integer_power
POPQ %rsi
POPQ %rdi
MOVQ %rax, %rbx
MOVQ $16, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ $5, %rbx
MOVQ -8(%rbp), %r11
PUSHQ %rdi
PUSHQ %rsi
MOVQ %rbx, %rdi
MOVQ %r11, %rsi
CALL integer_power
POPQ %rsi
POPQ %rdi
MOVQ %rax, %rbx
MOVQ y, %r11
MOVQ %rbx, %rax
IMUL %r11
MOVQ %rax, %r11
ADDQ %r10, %r11
MOVQ %r11, -24(%rbp)
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L1:
.string "\n"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ $17634, %r10
CMP %r10, %rbx
JNE .L4
MOVQ $0, %r10
JMP .L5
.L4:
MOVQ $1, %r10
.L5:
CMP $0, %r10
JE .L2
PUSHQ %rdi
.data
.L6:
.string "error...\n"
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L3
.L2:
.L3:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

17634


return code: 0


===[good17.bminor Input]===
// loops and calls
foo: function integer (x: integer) = {
    // return 0 if odd
    if (x%2 == 1) {
        return 0;
    }
    // else 1
    return 1;
}

main: function integer () = {
    i: integer;
    {
        {
            for (i=0; i<30; i++) {
                print foo(i), "\n";
            }
        }
    }
    return 0;
}
===[good17.bminor Output]===
.file "jchun2-compiler/test/codegen/good17.bminor"
.text
.global foo
foo:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %r10
MOVQ $1, %rbx
CMP %rbx, %r10
JE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L1
MOVQ $0, %r10
MOVQ %r10, %rax
JMP foo_end
JMP .L2
.L1:
.L2:
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP foo_end
foo_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, -8(%rbp)
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L5:
MOVQ -8(%rbp), %rbx
MOVQ $30, %r10
CMP %r10, %rbx
JL .L7
MOVQ $0, %r10
JMP .L8
.L7:
MOVQ $1, %r10
.L8:
CMP $0, %r10
JE .L6
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L9:
.string "\n"
.text
LEAQ .L9(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
INCQ -8(%rbp)
JMP .L5
.L6:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0
1
0


return code: 0


===[good18.bminor Input]===
foo: function integer (y: integer) = {
    return y * 2;
}

bar: function integer (x: integer) = {
    return x * 2;
}

main: function integer () = {
    x: integer = foo(bar(foo(bar(foo(bar(foo(bar(2))))))));
    print x;
    if (x != 2^9) {
        print "error...\n";
        return 1;
    }
    return 0;
}
===[good18.bminor Output]===
.file "jchun2-compiler/test/codegen/good18.bminor"
.text
.global foo
foo:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP foo_end
foo_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global bar
bar:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP bar_end
bar_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
MOVQ $2, %rbx
MOVQ %rbx, %rdi
CALL bar
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL bar
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL bar
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL bar
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ $9, %r11
PUSHQ %rdi
PUSHQ %rsi
MOVQ %r10, %rdi
MOVQ %r11, %rsi
CALL integer_power
POPQ %rsi
POPQ %rdi
MOVQ %rax, %r10
CMP %r10, %rbx
JNE .L3
MOVQ $0, %r10
JMP .L4
.L3:
MOVQ $1, %r10
.L4:
CMP $0, %r10
JE .L1
PUSHQ %rdi
.data
.L5:
.string "error...\n"
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L2
.L1:
.L2:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

512

return code: 0


===[good19.bminor Input]===
// more array tests
x: array [5] integer = {1, 2, 3, 4, 5};
main: function integer () = {
    y: integer = x[0];
    print y, "\n";
    if (y != x[0]) {
        print "error...\n";
        return 1;
    }

    x[3] = 20;
    print x[3], "\n";
    if (x[3] != 20) {
        print "error...\n";
        return 1;
    }

    i: integer = 0;
    for (; i<5; i++) {
        x[i] = i*2;
    }
    print x[4], "\n";
    if (x[4] != 8) {
        print "error...\n";
        return 1;
    }
    return 0;
}
===[good19.bminor Output]===
.file "jchun2-compiler/test/codegen/good19.bminor"
.data
x:
.quad 1
.quad 2
.quad 3
.quad 4
.quad 5
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
LEAQ x, %rbx
MOVQ $0, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L1:
.string "\n"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
LEAQ x, %r10
MOVQ $0, %r11
LEAQ 0(%r10, %r11, 8), %r12
MOVQ (%r12), %rbx
CMP %rbx, %rbx
JNE .L4
MOVQ $0, %rbx
JMP .L5
.L4:
MOVQ $1, %rbx
.L5:
CMP $0, %rbx
JE .L2
PUSHQ %rdi
.data
.L6:
.string "error...\n"
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L3
.L2:
.L3:
MOVQ $20, %rbx
LEAQ x, %r10
MOVQ $3, %r11
LEAQ 0(%r10, %r11, 8), %r12
MOVQ %rbx, (%r12)
PUSHQ %rdi
LEAQ x, %rbx
MOVQ $3, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L7:
.string "\n"
.text
LEAQ .L7(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
LEAQ x, %rbx
MOVQ $3, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ $20, %rbx
CMP %rbx, %rbx
JNE .L10
MOVQ $0, %rbx
JMP .L11
.L10:
MOVQ $1, %rbx
.L11:
CMP $0, %rbx
JE .L8
PUSHQ %rdi
.data
.L12:
.string "error...\n"
.text
LEAQ .L12(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L9
.L8:
.L9:
MOVQ $0, %rbx
MOVQ %rbx, -16(%rbp)
.L13:
MOVQ -16(%rbp), %rbx
MOVQ $5, %r10
CMP %r10, %rbx
JL .L15
MOVQ $0, %r10
JMP .L16
.L15:
MOVQ $1, %r10
.L16:
CMP $0, %r10
JE .L14
MOVQ -16(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
LEAQ x, %rbx
MOVQ -16(%rbp), %r11
LEAQ 0(%rbx, %r11, 8), %r13
MOVQ %r10, (%r13)
MOVQ -16(%rbp), %rbx
INCQ -16(%rbp)
JMP .L13
.L14:
PUSHQ %rdi
LEAQ x, %rbx
MOVQ $4, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L17:
.string "\n"
.text
LEAQ .L17(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
LEAQ x, %rbx
MOVQ $4, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ $8, %rbx
CMP %rbx, %rbx
JNE .L20
MOVQ $0, %rbx
JMP .L21
.L20:
MOVQ $1, %rbx
.L21:
CMP $0, %rbx
JE .L18
PUSHQ %rdi
.data
.L22:
.string "error...\n"
.text
LEAQ .L22(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L19
.L18:
.L19:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

1
20
8


return code: 0


===[good2.bminor Input]===
// Mult

main: function integer () = {
	x: integer = 2;
	y: integer = x * 3;
	z: integer = 2 * 2 * 2 * x;

	print "should be 6: ", y, " should be 16: ", z, " should be 0: ", z*0, "\n";

	if (x != 2 || y != 6 || z != 16 ) {
		print "error..\n";
		return 1;
	} else {
		return 0;
	}
}
===[good2.bminor Output]===
.file "jchun2-compiler/test/codegen/good2.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $2, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ $3, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ %r10, -16(%rbp)
MOVQ $2, %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ $2, %rbx
MOVQ %r10, %rax
IMUL %rbx
MOVQ %rax, %rbx
MOVQ -8(%rbp), %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ %r10, -24(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 6: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " should be 16: "
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L3:
.string " should be 0: "
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ $0, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ %r10, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string "\n"
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
CMP %r10, %rbx
JNE .L7
MOVQ $0, %r10
JMP .L8
.L7:
MOVQ $1, %r10
.L8:
MOVQ -16(%rbp), %rbx
MOVQ $6, %r11
CMP %r11, %rbx
JNE .L9
MOVQ $0, %r11
JMP .L10
.L9:
MOVQ $1, %r11
.L10:
CMPQ $1, %r10
JE .L11
CMPQ $1, %r10
JE .L11
MOVQ $0, %r11
JMP .L12
.L11:
MOVQ $1, %r11
.L12:
MOVQ -24(%rbp), %rbx
MOVQ $16, %r10
CMP %r10, %rbx
JNE .L13
MOVQ $0, %r10
JMP .L14
.L13:
MOVQ $1, %r10
.L14:
CMPQ $1, %r11
JE .L15
CMPQ $1, %r11
JE .L15
MOVQ $0, %r10
JMP .L16
.L15:
MOVQ $1, %r10
.L16:
CMP $0, %r10
JE .L5
PUSHQ %rdi
.data
.L17:
.string "error..\n"
.text
LEAQ .L17(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L6
.L5:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
.L6:
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 6: 6 should be 16: 16 should be 0: 0


return code: 0


===[good3.bminor Input]===
// Exp

main: function integer () = {
	x: integer = 2;
	y: integer = x^3;
	z: integer = y^2;

	print "should be 8: ", y, " should be 64: ", z, " should be 1: ", z^0, "\n";

	if (x != 2 || y != 8 || z != 64 ) {
		print "error..\n";
		return 1;
	} else {
		return 0;
	}
}
===[good3.bminor Output]===
.file "jchun2-compiler/test/codegen/good3.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $2, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ $3, %r10
PUSHQ %rdi
PUSHQ %rsi
MOVQ %rbx, %rdi
MOVQ %r10, %rsi
CALL integer_power
POPQ %rsi
POPQ %rdi
MOVQ %rax, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ $2, %r10
PUSHQ %rdi
PUSHQ %rsi
MOVQ %rbx, %rdi
MOVQ %r10, %rsi
CALL integer_power
POPQ %rsi
POPQ %rdi
MOVQ %rax, %rbx
MOVQ %rbx, -24(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 8: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " should be 64: "
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L3:
.string " should be 1: "
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ $0, %r10
PUSHQ %rdi
PUSHQ %rsi
MOVQ %rbx, %rdi
MOVQ %r10, %rsi
CALL integer_power
POPQ %rsi
POPQ %rdi
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string "\n"
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
CMP %r10, %rbx
JNE .L7
MOVQ $0, %r10
JMP .L8
.L7:
MOVQ $1, %r10
.L8:
MOVQ -16(%rbp), %rbx
MOVQ $8, %r11
CMP %r11, %rbx
JNE .L9
MOVQ $0, %r11
JMP .L10
.L9:
MOVQ $1, %r11
.L10:
CMPQ $1, %r10
JE .L11
CMPQ $1, %r10
JE .L11
MOVQ $0, %r11
JMP .L12
.L11:
MOVQ $1, %r11
.L12:
MOVQ -24(%rbp), %rbx
MOVQ $64, %r10
CMP %r10, %rbx
JNE .L13
MOVQ $0, %r10
JMP .L14
.L13:
MOVQ $1, %r10
.L14:
CMPQ $1, %r11
JE .L15
CMPQ $1, %r11
JE .L15
MOVQ $0, %r10
JMP .L16
.L15:
MOVQ $1, %r10
.L16:
CMP $0, %r10
JE .L5
PUSHQ %rdi
.data
.L17:
.string "error..\n"
.text
LEAQ .L17(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L6
.L5:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
.L6:
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 8: 8 should be 64: 64 should be 1: 1


return code: 0


===[good4.bminor Input]===
// Div

main: function integer () = {
	x: integer = 40;
	y: integer = x/2;
	z: integer = x/y;

	print "should be 20: ", y, " should be 2: ", z, " should be 0: ", 0/z, "\n";

	if (y != 20 || z != 2 ) {
		print "error..\n";
		return 1;
	} else {
		return 0;
	}
}
===[good4.bminor Output]===
.file "jchun2-compiler/test/codegen/good4.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $24, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $40, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rax, %r10
MOVQ %r10, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rax, %r10
MOVQ %r10, -24(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 20: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " should be 2: "
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -24(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L3:
.string " should be 0: "
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ $0, %rbx
MOVQ -24(%rbp), %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string "\n"
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ $20, %r10
CMP %r10, %rbx
JNE .L7
MOVQ $0, %r10
JMP .L8
.L7:
MOVQ $1, %r10
.L8:
MOVQ -24(%rbp), %rbx
MOVQ $2, %r11
CMP %r11, %rbx
JNE .L9
MOVQ $0, %r11
JMP .L10
.L9:
MOVQ $1, %r11
.L10:
CMPQ $1, %r10
JE .L11
CMPQ $1, %r10
JE .L11
MOVQ $0, %r11
JMP .L12
.L11:
MOVQ $1, %r11
.L12:
CMP $0, %r11
JE .L5
PUSHQ %rdi
.data
.L13:
.string "error..\n"
.text
LEAQ .L13(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L6
.L5:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
.L6:
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 20: 20 should be 2: 2 should be 0: 0


return code: 0


===[good5.bminor Input]===
// Different types of expr

main: function integer () = {
	// Chained assigns
	x: integer = 3;
	y: integer;
	z: integer;
	z = y = x;

	print "should be 3: ", x, " && ", y, "\n";
	if (y != 3 || x != 3) 
		return 1;

	// Local string decls
	foo: string = "hello world\n";
	bar: string = "my name is josh\n";
	foo2: string = "ok lol a lot of strings wooo\n";
	print foo, bar, foo2, "now this string is not from a var\n";

	test: string = foo;
	test2: string = foo2;
	print "these strings should be same: \n";
	print test;
	print foo;
	print test2;
	print foo2;
	return 0;
	
}
===[good5.bminor Output]===
.file "jchun2-compiler/test/codegen/good5.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $64, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $3, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $0, -16(%rbp)
MOVQ $0, -24(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, -16(%rbp)
MOVQ %rbx, -24(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 3: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string " && "
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L3:
.string "\n"
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ $3, %r10
CMP %r10, %rbx
JNE .L6
MOVQ $0, %r10
JMP .L7
.L6:
MOVQ $1, %r10
.L7:
MOVQ -8(%rbp), %rbx
MOVQ $3, %r11
CMP %r11, %rbx
JNE .L8
MOVQ $0, %r11
JMP .L9
.L8:
MOVQ $1, %r11
.L9:
CMPQ $1, %r10
JE .L10
CMPQ $1, %r10
JE .L10
MOVQ $0, %r11
JMP .L11
.L10:
MOVQ $1, %r11
.L11:
CMP $0, %r11
JE .L4
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L5
.L4:
.L5:
.data
.L12:
.string "hello world\n"
.text
LEAQ .L12(%rip), %rbx
MOVQ %rbx, -32(%rbp)
.data
.L13:
.string "my name is josh\n"
.text
LEAQ .L13(%rip), %rbx
MOVQ %rbx, -40(%rbp)
.data
.L14:
.string "ok lol a lot of strings wooo\n"
.text
LEAQ .L14(%rip), %rbx
MOVQ %rbx, -48(%rbp)
PUSHQ %rdi
MOVQ -32(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -40(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -48(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L15:
.string "now this string is not from a var\n"
.text
LEAQ .L15(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -32(%rbp), %rbx
MOVQ %rbx, -56(%rbp)
MOVQ -48(%rbp), %rbx
MOVQ %rbx, -64(%rbp)
PUSHQ %rdi
.data
.L16:
.string "these strings should be same: \n"
.text
LEAQ .L16(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -56(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -32(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -64(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -48(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 3: 3 && 3
hello world
my name is josh
ok lol a lot of strings wooo
now this string is not from a var
these strings should be same: 
hello world
hello world
ok lol a lot of strings wooo
ok lol a lot of strings wooo


return code: 0


===[good6.bminor Input]===
// Different types of expr

main: function integer () = {

	// Boolean tests
	q: boolean = true;
	w: boolean = false;
	print q, "\n";
	print w, "\n";
	if (q != true || q != false) {
		return 1;
	}
	print q==true, "\n";
	print w==false, "\n";
	
	y: integer = 4;
	true_b: boolean = (y == 4 && 3+y == 7);
	false_b: boolean = (3 == 3 && y == 4 && 3+y == 8);
	print "should be true: ", true_b, " should be false: ", false_b, "\n";
	if (true_b) {
		return 0;
	} else {
		print "error...\n";
		return 1;
	}
}
===[good6.bminor Output]===
.file "jchun2-compiler/test/codegen/good6.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $40, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $1, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ $0, %rbx
MOVQ %rbx, -16(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
.data
.L1:
.string "\n"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string "\n"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $1, %r10
CMP %r10, %rbx
JNE .L5
MOVQ $0, %r10
JMP .L6
.L5:
MOVQ $1, %r10
.L6:
MOVQ -8(%rbp), %rbx
MOVQ $0, %r11
CMP %r11, %rbx
JNE .L7
MOVQ $0, %r11
JMP .L8
.L7:
MOVQ $1, %r11
.L8:
CMPQ $1, %r10
JE .L9
CMPQ $1, %r10
JE .L9
MOVQ $0, %r11
JMP .L10
.L9:
MOVQ $1, %r11
.L10:
CMP $0, %r11
JE .L3
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L4
.L3:
.L4:
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $1, %r10
CMP %r10, %rbx
JE .L11
MOVQ $0, %r10
JMP .L12
.L11:
MOVQ $1, %r10
.L12:
MOVQ %r10, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
.data
.L13:
.string "\n"
.text
LEAQ .L13(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ $0, %r10
CMP %r10, %rbx
JE .L14
MOVQ $0, %r10
JMP .L15
.L14:
MOVQ $1, %r10
.L15:
MOVQ %r10, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
.data
.L16:
.string "\n"
.text
LEAQ .L16(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $4, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -24(%rbp), %rbx
MOVQ $4, %r10
CMP %r10, %rbx
JE .L17
MOVQ $0, %r10
JMP .L18
.L17:
MOVQ $1, %r10
.L18:
MOVQ $3, %rbx
MOVQ -24(%rbp), %r11
ADDQ %rbx, %r11
MOVQ $7, %rbx
CMP %rbx, %r11
JE .L19
MOVQ $0, %rbx
JMP .L20
.L19:
MOVQ $1, %rbx
.L20:
CMPQ $0, %r10
JE .L21
CMPQ $0, %rbx
JE .L21
MOVQ $1, %rbx
JMP .L22
.L21:
MOVQ $0, %rbx
.L22:
MOVQ %rbx, -32(%rbp)
MOVQ $3, %rbx
MOVQ $3, %r10
CMP %r10, %rbx
JE .L23
MOVQ $0, %r10
JMP .L24
.L23:
MOVQ $1, %r10
.L24:
MOVQ -24(%rbp), %rbx
MOVQ $4, %r11
CMP %r11, %rbx
JE .L25
MOVQ $0, %r11
JMP .L26
.L25:
MOVQ $1, %r11
.L26:
CMPQ $0, %r10
JE .L27
CMPQ $0, %r11
JE .L27
MOVQ $1, %r11
JMP .L28
.L27:
MOVQ $0, %r11
.L28:
MOVQ $3, %rbx
MOVQ -24(%rbp), %r10
ADDQ %rbx, %r10
MOVQ $8, %rbx
CMP %rbx, %r10
JE .L29
MOVQ $0, %rbx
JMP .L30
.L29:
MOVQ $1, %rbx
.L30:
CMPQ $0, %r11
JE .L31
CMPQ $0, %rbx
JE .L31
MOVQ $1, %rbx
JMP .L32
.L31:
MOVQ $0, %rbx
.L32:
MOVQ %rbx, -40(%rbp)
PUSHQ %rdi
.data
.L33:
.string "should be true: "
.text
LEAQ .L33(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -32(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
.data
.L34:
.string " should be false: "
.text
LEAQ .L34(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -40(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
.data
.L35:
.string "\n"
.text
LEAQ .L35(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -32(%rbp), %rbx
CMP $0, %rbx
JE .L36
MOVQ $0, %r10
MOVQ %r10, %rax
JMP main_end
JMP .L37
.L36:
PUSHQ %rdi
.data
.L38:
.string "error...\n"
.text
LEAQ .L38(%rip), %r10
MOVQ %r10, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %r10
MOVQ %r10, %rax
JMP main_end
.L37:
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

true
false
true
true
should be true: true should be false: false


return code: 0


===[good7.bminor Input]===
// Different types of expr

main: function integer () = {
	// Test chars
	x: char = 'c';
	print x, '\n';
	if (x != 'c') {
		print "error..\n";
		return 1;
	}

	// Test inc and dec
	z: integer = 3;
	z++;
	print "should be 4: ", z, "\n";
	if (z != 4) {
		return 1;
	}
	z--;
	z--;
	print "should be 2: ", z, "\n";
	if (z != 2) {
		return 1;
	}
    return 0;
}
===[good7.bminor Output]===
.file "jchun2-compiler/test/codegen/good7.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $99, %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
PUSHQ %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $99, %r10
CMP %r10, %rbx
JNE .L3
MOVQ $0, %r10
JMP .L4
.L3:
MOVQ $1, %r10
.L4:
CMP $0, %r10
JE .L1
PUSHQ %rdi
.data
.L5:
.string "error..\n"
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L2
.L1:
.L2:
MOVQ $3, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -16(%rbp), %rbx
INCQ -16(%rbp)
PUSHQ %rdi
.data
.L6:
.string "should be 4: "
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L7:
.string "\n"
.text
LEAQ .L7(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ $4, %r10
CMP %r10, %rbx
JNE .L10
MOVQ $0, %r10
JMP .L11
.L10:
MOVQ $1, %r10
.L11:
CMP $0, %r10
JE .L8
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L9
.L8:
.L9:
MOVQ -16(%rbp), %rbx
DECQ -16(%rbp)
MOVQ -16(%rbp), %rbx
DECQ -16(%rbp)
PUSHQ %rdi
.data
.L12:
.string "should be 2: "
.text
LEAQ .L12(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L13:
.string "\n"
.text
LEAQ .L13(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ $2, %r10
CMP %r10, %rbx
JNE .L16
MOVQ $0, %r10
JMP .L17
.L16:
MOVQ $1, %r10
.L17:
CMP $0, %r10
JE .L14
MOVQ $1, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L15
.L14:
.L15:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

c
should be 4: 4
should be 2: 2


return code: 0


===[good8.bminor Input]===
// nested func calls test
foo: function integer (y: integer) = {
	return y + 5;
}

bar: function integer (z: integer) = {
	l: integer = 10;
	return l + z;
}

main: function integer () = {
	x: integer = foo(5);
	print "should be 10: ", x, "\n";
	y: integer = bar(10);
	print "should be 20: ", y, "\n";
	print "should be 15: ", foo(x), "\n";
	print "should be 25: ", foo(y), "\n";
	print "should be 25: ", foo(bar(foo(5))), "\n";
    return 0;
}

===[good8.bminor Output]===
.file "jchun2-compiler/test/codegen/good8.bminor"
.text
.global foo
foo:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %rbx
MOVQ $5, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP foo_end
foo_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global bar
bar:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $10, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP bar_end
bar_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
MOVQ $5, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
.data
.L1:
.string "should be 10: "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string "\n"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %r10
PUSHQ %r11
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL bar
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -16(%rbp)
PUSHQ %rdi
.data
.L3:
.string "should be 20: "
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string "\n"
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L5:
.string "should be 15: "
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L6:
.string "\n"
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L7:
.string "should be 25: "
.text
LEAQ .L7(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L8:
.string "\n"
.text
LEAQ .L8(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L9:
.string "should be 25: "
.text
LEAQ .L9(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
PUSHQ %r10
PUSHQ %r11
MOVQ $5, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL bar
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L10:
.string "\n"
.text
LEAQ .L10(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

should be 10: 10
should be 20: 20
should be 15: 15
should be 25: 25
should be 25: 25


return code: 0


===[good9.bminor Input]===
// loops

main: function integer () = {
	x: boolean = true;
	if (x) {
		i: integer = 0;
		for (; i < 20; i++) {
			{
				print i, "\n";
			}
		}
	}
    return 0;
}

===[good9.bminor Output]===
.file "jchun2-compiler/test/codegen/good9.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $1, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
CMP $0, %rbx
JE .L1
MOVQ $0, %r10
MOVQ %r10, -16(%rbp)
.L3:
MOVQ -16(%rbp), %r10
MOVQ $20, %r11
CMP %r11, %r10
JL .L5
MOVQ $0, %r11
JMP .L6
.L5:
MOVQ $1, %r11
.L6:
CMP $0, %r11
JE .L4
PUSHQ %rdi
MOVQ -16(%rbp), %r10
MOVQ %r10, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L7:
.string "\n"
.text
LEAQ .L7(%rip), %r10
MOVQ %r10, %rdi
CALL print_string
POPQ %rdi
MOVQ -16(%rbp), %r10
INCQ -16(%rbp)
JMP .L3
.L4:
JMP .L2
.L1:
.L2:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19


return code: 0


====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good1.bminor.s: Assembler messages:
../hidden-tests/codegen/good1.bminor.s:211: Error: symbol `f' is already defined
../hidden-tests/codegen/good1.bminor.s:232: Error: symbol `f_end' is already defined

return code: 1


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Output]===
.file "../hidden-tests/codegen/good11.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $40, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $20, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, -16(%rbp)
MOVQ $10, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -24(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ $2, %rbx
MOVQ %rbx, -32(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -32(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ $3, %rbx
MOVQ %rbx, -40(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -40(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 95


===[good8.bminor Input]===
abs: function integer(n: integer);

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===[good8.bminor Output]===
TEST NOT PASSED - RUNTIME ERROR



return code: -11


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good13.bminor.s: Assembler messages:
../hidden-tests/codegen/good13.bminor.s:153: Error: symbol `foo' is already defined
../hidden-tests/codegen/good13.bminor.s:177: Error: symbol `foo_end' is already defined

return code: 1


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Output]===
.file "../hidden-tests/codegen/good12.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $4, %rbx
MOVQ $9, %r10
MOVQ $2, %r11
NEG %r11
MOVQ $5, %r12
NEG %r12
SUBQ %r12, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rax, %r11
ADDQ %rbx, %r11
MOVQ $2, %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ $4, %rbx
MOVQ %r10, %rax
IMUL %rbx
MOVQ %rax, %rbx
MOVQ $1, %r10
SUBQ %r10, %rbx
MOVQ $3, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %r10
MOVQ $7, %rbx
MOVQ %r10, %rax
IMUL %rbx
MOVQ %rax, %rbx
ADDQ %r11, %rbx
MOVQ $8, %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 13


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Output]===
.file "../hidden-tests/codegen/good15.bminor"
.text
.global strdup
strdup:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
strdup_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
.data
.L1:
.string "sssss"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %r10
PUSHQ %r11
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL strdup
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, -16(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r10
CMP %r10, %rbx
JE .L4
MOVQ $0, %r10
JMP .L5
.L4:
MOVQ $1, %r10
.L5:
CMP $0, %r10
JE .L2
MOVQ $22, %rbx
MOVQ %rbx, %rax
JMP main_end
JMP .L3
.L2:
MOVQ $11, %rbx
MOVQ %rbx, %rax
JMP main_end
.L3:
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 11


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===[good17.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

parse error: syntax error


return code: 1


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Output]===
.file "../hidden-tests/codegen/good18.bminor"
.data
b1:
.quad 3
.data
b2:
.quad 6
.data
b3:
.quad 9
.text
.global B
B:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
MOVQ b1, %rbx
MOVQ b2, %r10
MOVQ %rbx, %rax
IMUL %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %rbx
MOVQ -16(%rbp), %r11
MOVQ %rbx, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
ADDQ %r10, %r11
MOVQ %r11, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
MOVQ $37, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rax
JMP B_end
B_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
MOVQ $5, %rbx
MOVQ %rbx, %rdi
MOVQ $3, %rbx
MOVQ %rbx, %rsi
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
MOVQ b3, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

20
37

return code: 9


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Output]===
.file "../hidden-tests/codegen/good4.bminor"
.text
.global collatz
collatz:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L1:
.string " "
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string "\n"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ $1, %r10
CMP %r10, %rbx
JE .L5
MOVQ $0, %r10
JMP .L6
.L5:
MOVQ $1, %r10
.L6:
CMP $0, %r10
JE .L3
MOVQ -16(%rbp), %rbx
MOVQ %rbx, %rax
JMP collatz_end
JMP .L4
.L3:
.L4:
MOVQ -8(%rbp), %rbx
MOVQ $2, %r10
MOVQ %rbx, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %r10
MOVQ $0, %rbx
CMP %rbx, %r10
JE .L9
MOVQ $0, %rbx
JMP .L10
.L9:
MOVQ $1, %rbx
.L10:
CMP $0, %rbx
JE .L7
PUSHQ %r10
PUSHQ %r11
MOVQ -8(%rbp), %r10
MOVQ $2, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rdi
MOVQ -16(%rbp), %r10
MOVQ $1, %r11
ADDQ %r10, %r11
MOVQ %r11, %rsi
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP collatz_end
JMP .L8
.L7:
PUSHQ %r10
PUSHQ %r11
MOVQ $3, %r10
MOVQ -8(%rbp), %r11
MOVQ %r10, %rax
IMUL %r11
MOVQ %rax, %r11
MOVQ $1, %r10
ADDQ %r11, %r10
MOVQ %r10, %rdi
MOVQ -16(%rbp), %r10
MOVQ $1, %r11
ADDQ %r10, %r11
MOVQ %r11, %rsi
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP collatz_end
.L8:
collatz_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
MOVQ $27, %rbx
MOVQ %rbx, %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rsi
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

27 0
82 1
41 2
124 3
62 4
31 5
94 6
47 7
142 8
71 9
214 10
107 11
322 12
161 13
484 14
242 15
121 16
364 17
182 18
91 19
274 20
137 21
412 22
206 23
103 24
310 25
155 26
466 27
233 28
700 29
350 30
175 31
526 32
263 33
790 34
395 35
1186 36
593 37
1780 38
890 39
445 40
1336 41
668 42
334 43
167 44
502 45
251 46
754 47
377 48
1132 49
566 50
283 51
850 52
425 53
1276 54
638 55
319 56
958 57
479 58
1438 59
719 60
2158 61
1079 62
3238 63
1619 64
4858 65
2429 66
7288 67
3644 68
1822 69
911 70
2734 71
1367 72
4102 73
2051 74
6154 75
3077 76
9232 77
4616 78
2308 79
1154 80
577 81
1732 82
866 83
433 84
1300 85
650 86
325 87
976 88
488 89
244 90
122 91
61 92
184 93
92 94
46 95
23 96
70 97
35 98
106 99
53 100
160 101
80 102
40 103
20 104
10 105
5 106
16 107
8 108
4 109
2 110
1 111


return code: 111


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Output]===
.file "../hidden-tests/codegen/good20.bminor"
.text
.global D
D:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $64, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $5, %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ $1, %r10
ADDQ %rbx, %r10
MOVQ %r10, -16(%rbp)
MOVQ $9, %rbx
MOVQ %rbx, -24(%rbp)
MOVQ -24(%rbp), %rbx
MOVQ -8(%rbp), %r10
ADDQ %rbx, %r10
MOVQ $3, %rbx
SUBQ %rbx, %r10
MOVQ %r10, -32(%rbp)
MOVQ $1, %rbx
NEG %rbx
MOVQ %rbx, -40(%rbp)
MOVQ -32(%rbp), %rbx
MOVQ -24(%rbp), %r10
ADDQ %rbx, %r10
MOVQ %r10, -32(%rbp)
PUSHQ %rdi
MOVQ -32(%rbp), %rbx
MOVQ -40(%rbp), %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L1:
.string "\n"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $16, %rbx
MOVQ %rbx, -48(%rbp)
PUSHQ %rdi
MOVQ -16(%rbp), %rbx
MOVQ -48(%rbp), %r10
SUBQ %r10, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
MOVQ $2, %rbx
NEG %rbx
MOVQ %rbx, -56(%rbp)
MOVQ $1000, %rbx
MOVQ %rbx, -64(%rbp)
PUSHQ %rdi
MOVQ -64(%rbp), %rbx
MOVQ $10, %r10
ADDQ %rbx, %r10
MOVQ %r10, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string "\n"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ -56(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
PUSHQ %rdi
MOVQ -48(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
MOVQ $3, %rbx
MOVQ %rbx, %rax
JMP D_end
D_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL D
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

21
-10
1010
-2
16

return code: 3


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

parse error: syntax error


return code: 1


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good5.bminor.s: Assembler messages:
../hidden-tests/codegen/good5.bminor.s:197: Error: symbol `A' is already defined
../hidden-tests/codegen/good5.bminor.s:222: Error: symbol `A_end' is already defined
../hidden-tests/codegen/good5.bminor.s:239: Error: symbol `B' is already defined
../hidden-tests/codegen/good5.bminor.s:273: Error: symbol `B_end' is already defined
../hidden-tests/codegen/good5.bminor.s:290: Error: symbol `C' is already defined
../hidden-tests/codegen/good5.bminor.s:307: Error: symbol `C_end' is already defined

return code: 1


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===[good6.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

Type Error: Global variable integer (x) must be assigned a constant expression, given (-4)


return code: 1


===[good7.bminor Input]===
/*
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}
*/

infinite loop

===[good7.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

parse error: syntax error


return code: 1


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Output]===
.file "../hidden-tests/codegen/good9.bminor"
.data
a:
.zero 32
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $60, %rbx
LEAQ a, %r10
MOVQ $2, %r11
LEAQ 0(%r10, %r11, 8), %r12
MOVQ %rbx, (%r12)
LEAQ a, %rbx
MOVQ $2, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
LEAQ a, %rbx
MOVQ $2, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ $20, %rbx
MOVQ %rbx, %rax
CQO
IDIVQ %rbx
MOVQ %rax, %rbx
MOVQ $3, %rbx
MOVQ %rbx, %rax
IMUL %rbx
MOVQ %rax, %rbx
ADDQ %rbx, %rbx
LEAQ a, %rbx
MOVQ $1, %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
SUBQ %rbx, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 0


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Output]===
.file "../hidden-tests/codegen/good2.bminor"
.data
X:
.quad 11
.quad 30
.quad 22
.quad 0
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, -8(%rbp)
MOVQ $0, %rbx
MOVQ %rbx, -8(%rbp)
.L1:
LEAQ X, %rbx
MOVQ -8(%rbp), %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ $0, %rbx
CMP %rbx, %rbx
JNE .L3
MOVQ $0, %rbx
JMP .L4
.L3:
MOVQ $1, %rbx
.L4:
CMP $0, %rbx
JE .L2
PUSHQ %rdi
LEAQ X, %rbx
MOVQ -8(%rbp), %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
PUSHQ %rdi
LEAQ X, %rbx
MOVQ -8(%rbp), %r10
LEAQ 0(%rbx, %r10, 8), %r11
MOVQ (%r11), %rbx
MOVQ $3, %rbx
MOVQ %rbx, %rax
CQO
IDIVQ %rbx
MOVQ %rdx, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
MOVQ -8(%rbp), %rbx
INCQ -8(%rbp)
JMP .L1
.L2:
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET



return code: 0


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===[good19.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

Type Error: Global variable integer (c1) must be assigned a constant expression, given (-1)


return code: 1


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Output]===
.file "../hidden-tests/codegen/good10.bminor"
.data
w:
.string "no"
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
.data
.L1:
.string "ok"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string "\n"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.data
.L3:
.string "bad!\n"
.text
LEAQ .L3(%rip), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ $32, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
PUSHQ %rdi
LEAQ w(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
.data
.L4:
.string " "
.text
LEAQ .L4(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
.data
.L5:
.string "changed\n"
.text
LEAQ .L5(%rip), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
f_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
.data
.L6:
.string "good"
.text
LEAQ .L6(%rip), %rbx
MOVQ %rbx, -8(%rbp)
PUSHQ %r10
PUSHQ %r11
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
PUSHQ %rdi
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

ok
bad!
 no changed
good

return code: 0


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Output]===
.file "../hidden-tests/codegen/good14.bminor"
.data
s:
.string "ok\n"
.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
LEAQ s(%rip), %rbx
MOVQ %rbx, -8(%rbp)
MOVQ -8(%rbp), %rbx
MOVQ %rbx, %rax
JMP f_end
f_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

ok


return code: 0


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Output]===
.file "../hidden-tests/codegen/good16.bminor"
.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
PUSHQ %rdx
PUSHQ %rcx
PUSHQ %r8
PUSHQ %r9
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %rdi
.data
.L1:
.string "Testing printing literals"
.text
LEAQ .L1(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ $10, %rbx
MOVQ %rbx, %rdi
CALL print_character
POPQ %rdi
PUSHQ %rdi
MOVQ $123, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
PUSHQ %rdi
.data
.L2:
.string "abc"
.text
LEAQ .L2(%rip), %rbx
MOVQ %rbx, %rdi
CALL print_string
POPQ %rdi
PUSHQ %rdi
MOVQ $1, %rbx
MOVQ %rbx, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rdi
CALL print_boolean
POPQ %rdi
PUSHQ %rdi
MOVQ $5, %rbx
MOVQ %rbx, %rdi
CALL print_integer
POPQ %rdi
MOVQ $0, %rbx
MOVQ %rbx, %rax
JMP main_end
main_end:
POPQ %r15
POPQ %r14
POPQ %r13
POPQ %r12
POPQ %rbx
POPQ %r9
POPQ %r8
POPQ %rcx
POPQ %rdx
POPQ %rsi
POPQ %rdi
MOVQ %rbp, %rsp
POPQ %rbp
RET

Testing printing literals
123abctruefalse5

return code: 0


====Bad Tests====
===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 12,
      "incorrect": 9
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Codegen Project Grade
-------------------

General Structure: 22/25
---------------------------------
Overall structure is correct. Some issues generating code
and typechecking global negative numbers

Codegen - Functionality 12/15 
--------------------------------------------
some crashes in assembled programs

Codegen - Assembly Structure 10/10 
--------------------------------------------
assembly looks good 

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 12/20
---------------------------
Passes 12 hidden tests

Code Style: 10/10
------------------------
Looks good. Nice work

Extra Credit: 0/10
------------------------

Total: 85/100
------------------------------------------
