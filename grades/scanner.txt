=====STUDENT TESTS=====
====Good Tests====
===[STUDENT TESTS/good0.bminor Input]===
testing
idents
_this
sho1d
a11_
w0rk
wooooooooo


===[STUDENT TESTS/good0.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good0.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     idents
IDENTIFIER     _this
IDENTIFIER     sho1d
IDENTIFIER     a11_
IDENTIFIER     w0rk
IDENTIFIER     wooooooooo




===[STUDENT TESTS/good1.bminor Input]===
keywords
array
auto
boolean
char
else
    false
    float
    for
        function
        if
            integer
            print
            return
            string
            true
            void
            while

===[STUDENT TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good1.bminor Output]===
IDENTIFIER     keywords
ARRAY          array
AUTO           auto
BOOL           boolean
CHAR           char
ELSE           else
FALSE          false
FLOAT          float
FOR            for
FOR            function
IF             if
INT            integer
PRINT          print
RETURN         return
STRING         string
TRUE           true
VOID           void
WHILE          while




===[STUDENT TESTS/good10.bminor Input]===
printarray: function void ( a: array [] integer ) = {
	i: integer;
	for( i=0;i<array_length(a);i++) {
		print a[i], "\n";
	}
}

===[STUDENT TESTS/good10.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good10.bminor Output]===
IDENTIFIER     printarray
DEFINE         :
FOR            function
VOID           void
LEFT PAREN     (
IDENTIFIER     a
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
IDENTIFIER     array_length
LEFT PAREN     (
IDENTIFIER     a
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     a
LEFT BRACKET   [
IDENTIFIER     i
RIGHT BRACKET  ]
COMMA          ,
STRING LITERAL 

SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }




===[STUDENT TESTS/good2.bminor Input]===
testing expr
x: integer = 3;
y: integer = x + 5;
(paren)
x++

===[STUDENT TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good2.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     expr
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    3
SEMICOLON      ;
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
IDENTIFIER     x
ADD            +
INT LITERAL    5
SEMICOLON      ;
LEFT PAREN     (
IDENTIFIER     paren
RIGHT PAREN    )
IDENTIFIER     x
INCREMENT      ++




===[STUDENT TESTS/good3.bminor Input]===
testing functionality
y: integer = 0;
for (x: integer = 0; i<5; i++) {
        y = y + x;
    }

===[STUDENT TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good3.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     functionality
IDENTIFIER     y
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     x
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     y
ASSIGN         =
IDENTIFIER     y
ADD            +
IDENTIFIER     x
SEMICOLON      ;
RIGHT BRACE    }




===[STUDENT TESTS/good4.bminor Input]===
testing more math ops
foo: integer = 0;
foo = foo / 5;
foo = 5 % 2;
foo = 5^2
foo = 5 * 6
foo-;

===[STUDENT TESTS/good4.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good4.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     more
IDENTIFIER     math
IDENTIFIER     ops
IDENTIFIER     foo
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     foo
ASSIGN         =
IDENTIFIER     foo
DIVISION       /
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     foo
ASSIGN         =
INT LITERAL    5
MODULO         %
INT LITERAL    2
SEMICOLON      ;
IDENTIFIER     foo
ASSIGN         =
INT LITERAL    5
EXPONENT       ^
INT LITERAL    2
IDENTIFIER     foo
ASSIGN         =
INT LITERAL    5
MULTIPLY       *
INT LITERAL    6
IDENTIFIER     foo
NEGATIVE       -
SEMICOLON      ;




===[STUDENT TESTS/good5.bminor Input]===
testing logical ops
if (x == 2 || x == 3)

if (x == 2 && x == 3) {
        y = 2;
} else {
    y = 5;
}

if (x <= 2 || x >= 5 && y > 2 || s < 5)



===[STUDENT TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good5.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     logical
IDENTIFIER     ops
IF             if
LEFT PAREN     (
IDENTIFIER     x
EQUALITY       ==
INT LITERAL    2
OR             ||
IDENTIFIER     x
EQUALITY       ==
INT LITERAL    3
RIGHT PAREN    )
IF             if
LEFT PAREN     (
IDENTIFIER     x
EQUALITY       ==
INT LITERAL    2
AND            &&
IDENTIFIER     x
EQUALITY       ==
INT LITERAL    3
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     y
ASSIGN         =
INT LITERAL    2
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
IDENTIFIER     y
ASSIGN         =
INT LITERAL    5
SEMICOLON      ;
RIGHT BRACE    }
IF             if
LEFT PAREN     (
IDENTIFIER     x
LEQ            <=
INT LITERAL    2
OR             ||
IDENTIFIER     x
GEQ            >=
INT LITERAL    5
AND            &&
IDENTIFIER     y
GREATER THAN   >
INT LITERAL    2
OR             ||
IDENTIFIER     s
LESS THAN      <
INT LITERAL    5
RIGHT PAREN    )




===[STUDENT TESTS/good6.bminor Input]===
testing literals
123456
543.1
1231.002
00002.
-21.5
-24
10e9
-2e-2
242552.241
"This is a string literal with new line\n"
"Hello world \'Yessir in little quotes \'"
'\t'
'z'

===[STUDENT TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good6.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     literals
INT LITERAL    123456
FLOAT LITERAL  543.100000
FLOAT LITERAL  1231.002000
FLOAT LITERAL  2.000000
NEGATIVE       -
FLOAT LITERAL  21.500000
NEGATIVE       -
INT LITERAL    24
FLOAT LITERAL  10000000000.000000
NEGATIVE       -
FLOAT LITERAL  0.020000
FLOAT LITERAL  242552.241000
STRING LITERAL This is a string literal with new line

STRING LITERAL Hello world 'Yessir in little quotes '
CHAR LITERAL   '\t' 	
CHAR LITERAL   'z' z




===[STUDENT TESTS/good7.bminor Input]===
/* testing c style comment */

// and this is a c++ style comment

/* ***** a lot of stars ** */

/* comment

with

new lines

*/

===[STUDENT TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good7.bminor Output]===
COMMENT        /* testing c style comment */

// and this is a c++ style comment

/* ***** a lot of stars ** */

/* comment

with

new lines

*/




===[STUDENT TESTS/good8.bminor Input]===
testing hex
'\0x32'
'\0xFF'
'\0x11'
'\0x52'

===[STUDENT TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good8.bminor Output]===




===[STUDENT TESTS/good9.bminor Input]===
testing small program

main: function integer ( argc: integer, argv: array [] string ) = {
   for (i=0; i<100; i++) {
       if (i % 2 == 0) {
            print i;
        }
    }
    return 0;
}

===[STUDENT TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good9.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     small
IDENTIFIER     program
IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     argc
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     argv
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
FOR            for
LEFT PAREN     (
IDENTIFIER     i
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     i
LESS THAN      <
INT LITERAL    100
SEMICOLON      ;
IDENTIFIER     i
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     i
MODULO         %
INT LITERAL    2
EQUALITY       ==
INT LITERAL    0
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
IDENTIFIER     i
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
RETURN         return
INT LITERAL    0
SEMICOLON      ;
RIGHT BRACE    }




====Bad Tests====
===[STUDENT TESTS/bad0.bminor Input]===
bad ident
@

===[STUDENT TESTS/bad0.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad0.bminor Output]===
IDENTIFIER     bad
IDENTIFIER     ident
ERROR          @




===[STUDENT TESTS/bad1.bminor Input]===
testing invalid string
"

===[STUDENT TESTS/bad1.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad1.bminor Output]===
IDENTIFIER     testing
IDENTIFIER     invalid
STRING         string
ERROR          "




===[STUDENT TESTS/bad10.bminor Input]===
//invalid ops
if (x & y) {
        print "hi"
}

===[STUDENT TESTS/bad10.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad10.bminor Output]===
COMMENT        //invalid ops

IF             if
LEFT PAREN     (
IDENTIFIER     x
ERROR          &




===[STUDENT TESTS/bad2.bminor Input]===
invalid hex
\0xZZ

===[STUDENT TESTS/bad2.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad2.bminor Output]===
IDENTIFIER     invalid
IDENTIFIER     hex
ERROR          \




===[STUDENT TESTS/bad3.bminor Input]===
//invalid character
'\'

===[STUDENT TESTS/bad3.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad3.bminor Output]===
COMMENT        //invalid character

ERROR          '




===[STUDENT TESTS/bad4.bminor Input]===
'\ac'

===[STUDENT TESTS/bad4.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad4.bminor Output]===
ERROR          '




===[STUDENT TESTS/bad5.bminor Input]===
// too long of string
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

===[STUDENT TESTS/bad5.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad5.bminor Output]===
COMMENT        // too long of string

ERROR          "




===[STUDENT TESTS/bad6.bminor Input]===
$minus

===[STUDENT TESTS/bad6.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad6.bminor Output]===
ERROR          $




===[STUDENT TESTS/bad7.bminor Input]===
// too big of integer
18446744073709551616

===[STUDENT TESTS/bad7.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad7.bminor Output]===
COMMENT        // too big of integer


ERROR: Integer too long



===[STUDENT TESTS/bad8.bminor Input]===
too long of ident
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

===[STUDENT TESTS/bad8.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad8.bminor Output]===
IDENTIFIER     too
IDENTIFIER     long
IDENTIFIER     of
IDENTIFIER     ident
ERROR          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa




===[STUDENT TESTS/bad9.bminor Input]===
"""

===[STUDENT TESTS/bad9.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad9.bminor Output]===
STRING LITERAL 
ERROR          "




=====HIDDEN TESTS=====
====Good Tests====
===[HIDDEN TESTS/good11.bminor Input]===
// some more complicated corner cases
z = -(5 * 4);
z = 15 + 5 - 4*3/7;
z = x + (y * 5 - (4 + 20/v) - 15) % 6 + z; //long integer expr
z+++; // these will cause parsing errors
w---;


===[HIDDEN TESTS/good11.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good11.bminor Output]===
COMMENT        // some more complicated corner cases

IDENTIFIER     z
ASSIGN         =
NEGATIVE       -
LEFT PAREN     (
INT LITERAL    5
MULTIPLY       *
INT LITERAL    4
RIGHT PAREN    )
SEMICOLON      ;
IDENTIFIER     z
ASSIGN         =
INT LITERAL    15
ADD            +
INT LITERAL    5
NEGATIVE       -
INT LITERAL    4
MULTIPLY       *
INT LITERAL    3
DIVISION       /
INT LITERAL    7
SEMICOLON      ;
IDENTIFIER     z
ASSIGN         =
IDENTIFIER     x
ADD            +
LEFT PAREN     (
IDENTIFIER     y
MULTIPLY       *
INT LITERAL    5
NEGATIVE       -
LEFT PAREN     (
INT LITERAL    4
ADD            +
INT LITERAL    20
DIVISION       /
IDENTIFIER     v
RIGHT PAREN    )
NEGATIVE       -
INT LITERAL    15
RIGHT PAREN    )
MODULO         %
INT LITERAL    6
ADD            +
IDENTIFIER     z
SEMICOLON      ;
COMMENT        //long integer expr

IDENTIFIER     z
INCREMENT      ++
ADD            +
SEMICOLON      ;
COMMENT        // these will cause parsing errors

IDENTIFIER     w
DECREMENT      --
NEGATIVE       -
SEMICOLON      ;




===[HIDDEN TESTS/good12.bminor Input]===
//tests the for/print keyword and while keyword
x:integer;
for(x = 0; x < 5; x++)
{
	print "counting: ", x;
}
a:integer = 0;
while(a > 0)
{
	a--;
}



===[HIDDEN TESTS/good12.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good12.bminor Output]===
COMMENT        //tests the for/print keyword and while keyword

IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     x
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     x
LESS THAN      <
INT LITERAL    5
SEMICOLON      ;
IDENTIFIER     x
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
STRING LITERAL counting: 
COMMA          ,
IDENTIFIER     x
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     a
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
WHILE          while
LEFT PAREN     (
IDENTIFIER     a
GREATER THAN   >
INT LITERAL    0
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     a
DECREMENT      --
SEMICOLON      ;
RIGHT BRACE    }




===[HIDDEN TESTS/good13.bminor Input]===
//test some odd identifier names
ident55
ident55_
ident__55__
thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt = 7
variable_names_may_contain_underscores_
_variables_can_start_with_an_underscore_67
7minus5 

===[HIDDEN TESTS/good13.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good13.bminor Output]===
COMMENT        //test some odd identifier names

IDENTIFIER     ident55
IDENTIFIER     ident55_
IDENTIFIER     ident__55__
IDENTIFIER     thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt
ASSIGN         =
INT LITERAL    7
IDENTIFIER     variable_names_may_contain_underscores_
IDENTIFIER     _variables_can_start_with_an_underscore_67
INT LITERAL    7
IDENTIFIER     minus5




===[HIDDEN TESTS/good14.bminor Input]===
main: function integer ( argc: integer, argv: array [] string ) =
{
}
boolFunction: function boolean(intVar:integer) =
{
	return intVar > 5;
}
intFunction: function integer(integer n) =
{
	total:integer = 0;
	int count;
	for(count = 0; count < n+1; count++)
	{
		total = total + count;
	
}


===[HIDDEN TESTS/good14.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good14.bminor Output]===
IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     argc
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     argv
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RIGHT BRACE    }
IDENTIFIER     boolFunction
DEFINE         :
FOR            function
BOOL           boolean
LEFT PAREN     (
IDENTIFIER     intVar
DEFINE         :
INT            integer
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
RETURN         return
IDENTIFIER     intVar
GREATER THAN   >
INT LITERAL    5
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     intFunction
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
INT            integer
IDENTIFIER     n
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     total
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     int
IDENTIFIER     count
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     count
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     count
LESS THAN      <
IDENTIFIER     n
ADD            +
INT LITERAL    1
SEMICOLON      ;
IDENTIFIER     count
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     total
ASSIGN         =
IDENTIFIER     total
ADD            +
IDENTIFIER     count
SEMICOLON      ;
RIGHT BRACE    }




===[HIDDEN TESTS/good15.bminor Input]===
intFunction: function integer(intVar:integer, boolVar: boolean)
{
	if(boolVar)
	{
		intVar = intVar * 2;
	}
	return intVar;
}
// finds the largest value in the array
getLargest: function integer(intArrVar:array [] integer, int len) =
{
	largest:integer = 0;
	x:integer;
	for(x = 0; x < len; x++)
	{
		if(intArrVar[x] > largest)
		{
			largest = intArrVar[x];
		}
	}
	return largest;
		
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	b:array [10] integer = {0,1,2,3,4,5};
	b[4] = 6;
	i:integer;
	z:integer = intFunction(i, true);
	print intArrFunction(v, z);
}

===[HIDDEN TESTS/good15.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good15.bminor Output]===
IDENTIFIER     intFunction
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     intVar
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     boolVar
DEFINE         :
BOOL           boolean
RIGHT PAREN    )
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     boolVar
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     intVar
ASSIGN         =
IDENTIFIER     intVar
MULTIPLY       *
INT LITERAL    2
SEMICOLON      ;
RIGHT BRACE    }
RETURN         return
IDENTIFIER     intVar
SEMICOLON      ;
RIGHT BRACE    }
COMMENT        // finds the largest value in the array

IDENTIFIER     getLargest
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     intArrVar
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
INT            integer
COMMA          ,
IDENTIFIER     int
IDENTIFIER     len
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     largest
DEFINE         :
INT            integer
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     x
DEFINE         :
INT            integer
SEMICOLON      ;
FOR            for
LEFT PAREN     (
IDENTIFIER     x
ASSIGN         =
INT LITERAL    0
SEMICOLON      ;
IDENTIFIER     x
LESS THAN      <
IDENTIFIER     len
SEMICOLON      ;
IDENTIFIER     x
INCREMENT      ++
RIGHT PAREN    )
LEFT BRACE     {
IF             if
LEFT PAREN     (
IDENTIFIER     intArrVar
LEFT BRACKET   [
IDENTIFIER     x
RIGHT BRACKET  ]
GREATER THAN   >
IDENTIFIER     largest
RIGHT PAREN    )
LEFT BRACE     {
IDENTIFIER     largest
ASSIGN         =
IDENTIFIER     intArrVar
LEFT BRACKET   [
IDENTIFIER     x
RIGHT BRACKET  ]
SEMICOLON      ;
RIGHT BRACE    }
RIGHT BRACE    }
RETURN         return
IDENTIFIER     largest
SEMICOLON      ;
RIGHT BRACE    }
IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     argc
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     argv
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
RIGHT PAREN    )
ASSIGN         =
LEFT BRACE     {
IDENTIFIER     b
DEFINE         :
ARRAY          array
LEFT BRACKET   [
INT LITERAL    10
RIGHT BRACKET  ]
INT            integer
ASSIGN         =
LEFT BRACE     {
INT LITERAL    0
COMMA          ,
INT LITERAL    1
COMMA          ,
INT LITERAL    2
COMMA          ,
INT LITERAL    3
COMMA          ,
INT LITERAL    4
COMMA          ,
INT LITERAL    5
RIGHT BRACE    }
SEMICOLON      ;
IDENTIFIER     b
LEFT BRACKET   [
INT LITERAL    4
RIGHT BRACKET  ]
ASSIGN         =
INT LITERAL    6
SEMICOLON      ;
IDENTIFIER     i
DEFINE         :
INT            integer
SEMICOLON      ;
IDENTIFIER     z
DEFINE         :
INT            integer
ASSIGN         =
IDENTIFIER     intFunction
LEFT PAREN     (
IDENTIFIER     i
COMMA          ,
TRUE           true
RIGHT PAREN    )
SEMICOLON      ;
PRINT          print
IDENTIFIER     intArrFunction
LEFT PAREN     (
IDENTIFIER     v
COMMA          ,
IDENTIFIER     z
RIGHT PAREN    )
SEMICOLON      ;
RIGHT BRACE    }




===[HIDDEN TESTS/good1.bminor Input]===
// Easy comment
/* Easy comment */

===[HIDDEN TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good1.bminor Output]===
COMMENT        // Easy comment

COMMENT        /* Easy comment */




===[HIDDEN TESTS/good10.bminor Input]===
// Modulus operator
15%3

// Exponentiation operator
2^6

// Negation
-value

// Postincrement and postdecrement
number++;

number--;

===[HIDDEN TESTS/good10.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good10.bminor Output]===
COMMENT        // Modulus operator

INT LITERAL    15
MODULO         %
INT LITERAL    3
COMMENT        // Exponentiation operator

INT LITERAL    2
EXPONENT       ^
INT LITERAL    6
COMMENT        // Negation

NEGATIVE       -
IDENTIFIER     value
COMMENT        // Postincrement and postdecrement

IDENTIFIER     number
INCREMENT      ++
SEMICOLON      ;
IDENTIFIER     number
DECREMENT      --
SEMICOLON      ;




===[HIDDEN TESTS/good2.bminor Input]===
////* Harder comment ***/
/******************/
/*
This one works too.
*/
/***************
Also a good comment.
****************/
// comment // comment // comment


===[HIDDEN TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good2.bminor Output]===
COMMENT        ////* Harder comment ***/

COMMENT        /******************/
/*
This one works too.
*/
/***************
Also a good comment.
****************/
COMMENT        // comment // comment // comment





===[HIDDEN TESTS/good3.bminor Input]===
// Identifiers
CamelCase
lower_case
skiddo23
B4UFLY
i
x15


===[HIDDEN TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good3.bminor Output]===
COMMENT        // Identifiers

IDENTIFIER     CamelCase
IDENTIFIER     lower_case
IDENTIFIER     skiddo23
IDENTIFIER     B4UFLY
IDENTIFIER     i
IDENTIFIER     x15




===[HIDDEN TESTS/good4.bminor Input]===
// Equality Operators
== != <= < > >=

===[HIDDEN TESTS/good4.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good4.bminor Output]===
COMMENT        // Equality Operators

EQUALITY       ==
INEQUALITY     !=
LEQ            <=
LESS THAN      <
GREATER THAN   >
GEQ            >=




===[HIDDEN TESTS/good5.bminor Input]===
// Various bits of punctuation
, : ; ( ) [ ] { }


===[HIDDEN TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good5.bminor Output]===
COMMENT        // Various bits of punctuation

COMMA          ,
DEFINE         :
SEMICOLON      ;
LEFT PAREN     (
RIGHT PAREN    )
LEFT BRACKET   [
RIGHT BRACKET  ]
LEFT BRACE     {
RIGHT BRACE    }




===[HIDDEN TESTS/good6.bminor Input]===
// Complete function prototype
main: function integer ( argc: integer, argv: array [] string );


===[HIDDEN TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good6.bminor Output]===
COMMENT        // Complete function prototype

IDENTIFIER     main
DEFINE         :
FOR            function
INT            integer
LEFT PAREN     (
IDENTIFIER     argc
DEFINE         :
INT            integer
COMMA          ,
IDENTIFIER     argv
DEFINE         :
ARRAY          array
LEFT BRACKET   [
RIGHT BRACKET  ]
STRING         string
RIGHT PAREN    )
SEMICOLON      ;




===[HIDDEN TESTS/good7.bminor Input]===
// Nested statements
if( x<15 ) {
    print "small";
} else {
    print "large!";
}


===[HIDDEN TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good7.bminor Output]===
COMMENT        // Nested statements

IF             if
LEFT PAREN     (
IDENTIFIER     x
LESS THAN      <
INT LITERAL    15
RIGHT PAREN    )
LEFT BRACE     {
PRINT          print
STRING LITERAL small
SEMICOLON      ;
RIGHT BRACE    }
ELSE           else
LEFT BRACE     {
PRINT          print
STRING LITERAL large!
SEMICOLON      ;
RIGHT BRACE    }




===[HIDDEN TESTS/good8.bminor Input]===
// Valid integers
0
1024
-512
+256
// valid floats
1.2
0.45
.67
12e10
+1.2
-1.2
1.2e+1
1.2e-1
+1.2e+1
+1.2e-1
-1.2e+1
-1.2e-1

===[HIDDEN TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good8.bminor Output]===
COMMENT        // Valid integers

INT LITERAL    0
INT LITERAL    1024
NEGATIVE       -
INT LITERAL    512
ADD            +
INT LITERAL    256
COMMENT        // valid floats

FLOAT LITERAL  1.200000
FLOAT LITERAL  0.450000
FLOAT LITERAL  0.670000
FLOAT LITERAL  120000000000.000000
ADD            +
FLOAT LITERAL  1.200000
NEGATIVE       -
FLOAT LITERAL  1.200000
FLOAT LITERAL  1.200000
FLOAT LITERAL  0.000000
FLOAT LITERAL  1.200000
FLOAT LITERAL  0.000000
ADD            +
FLOAT LITERAL  1.200000
FLOAT LITERAL  0.000000
ADD            +
FLOAT LITERAL  1.200000
FLOAT LITERAL  0.000000
NEGATIVE       -
FLOAT LITERAL  1.200000
FLOAT LITERAL  0.000000
NEGATIVE       -
FLOAT LITERAL  1.200000
FLOAT LITERAL  0.000000




===[HIDDEN TESTS/good9.bminor Input]===
// Type Keywords
array
boolean
char
string
void
integer
float

===[HIDDEN TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good9.bminor Output]===
COMMENT        // Type Keywords

ARRAY          array
BOOL           boolean
CHAR           char
STRING         string
VOID           void
INT            integer
FLOAT          float




====Bad Tests====
===[HIDDEN TESTS/bad11.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[HIDDEN TESTS/bad11.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad11.bminor Output]===
COMMENT        /*
A string should not contain a literal newline,
but use backslash-n instead.
*/
ERROR          "




===[HIDDEN TESTS/bad12.bminor Input]===
'ca'

===[HIDDEN TESTS/bad12.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad12.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad13.bminor Input]===
''

===[HIDDEN TESTS/bad13.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad13.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad14.bminor Input]===
'\ac'

===[HIDDEN TESTS/bad14.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad14.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad15.bminor Input]===
'

===[HIDDEN TESTS/bad15.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad15.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad1.bminor Input]===
"unmatched string""

===[HIDDEN TESTS/bad1.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad1.bminor Output]===
STRING LITERAL unmatched string
ERROR          "




===[HIDDEN TESTS/bad10.bminor Input]===
#compilers // No hashtags in B-minor

===[HIDDEN TESTS/bad10.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad10.bminor Output]===
ERROR          #




===[HIDDEN TESTS/bad2.bminor Input]===
"unterminated \"


===[HIDDEN TESTS/bad2.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad2.bminor Output]===
ERROR          "




===[HIDDEN TESTS/bad3.bminor Input]===
never started"






===[HIDDEN TESTS/bad3.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad3.bminor Output]===
IDENTIFIER     never
IDENTIFIER     started
ERROR          "




===[HIDDEN TESTS/bad4.bminor Input]===
'character?' // Character too long.

===[HIDDEN TESTS/bad4.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad4.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad5.bminor Input]===
'' // Empty character not allowed.

===[HIDDEN TESTS/bad5.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad5.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad6.bminor Input]===
~tilde // Invalid symbol

===[HIDDEN TESTS/bad6.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad6.bminor Output]===
ERROR          ~




===[HIDDEN TESTS/bad7.bminor Input]===
/* Is this a valid comment */ @ */


===[HIDDEN TESTS/bad7.bminor Status]===
return code: 0
TEST NOT PASSED

===[HIDDEN TESTS/bad7.bminor Output]===
COMMENT        /* Is this a valid comment */ @ */




===[HIDDEN TESTS/bad8.bminor Input]===
"\0xGG" // invalid escape sequence

===[HIDDEN TESTS/bad8.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad8.bminor Output]===

ERROR: Invalid hexadecimal backslash code: 0xGG



===[HIDDEN TESTS/bad9.bminor Input]===
minus#44

===[HIDDEN TESTS/bad9.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad9.bminor Output]===
IDENTIFIER     minus
ERROR          #




===[HIDDEN TESTS/bad16.bminor Input]===
@
#
&
|
\

===[HIDDEN TESTS/bad16.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad16.bminor Output]===
ERROR          @




===[HIDDEN TESTS/bad17.bminor Input]===
// unmatched comment throws error 
/* This is a comment.








===[HIDDEN TESTS/bad17.bminor Status]===
return code: 0
TEST NOT PASSED

===[HIDDEN TESTS/bad17.bminor Output]===
COMMENT        // unmatched comment throws error 

DIVISION       /
MULTIPLY       *
IDENTIFIER     This
IDENTIFIER     is
IDENTIFIER     a
IDENTIFIER     comment
FLOAT LITERAL  0.000000




===[HIDDEN TESTS/bad18.bminor Input]===
// basic data types
" the quote is unmatched







===[HIDDEN TESTS/bad18.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad18.bminor Output]===
COMMENT        // basic data types

ERROR          "




===[HIDDEN TESTS/bad19.bminor Input]===
// floating point mistake
5..6..0..5..0;

===[HIDDEN TESTS/bad19.bminor Status]===
return code: 0
TEST NOT PASSED

===[HIDDEN TESTS/bad19.bminor Output]===
COMMENT        // floating point mistake

FLOAT LITERAL  5.000000
FLOAT LITERAL  0.600000
FLOAT LITERAL  0.000000
FLOAT LITERAL  0.000000
FLOAT LITERAL  0.000000
FLOAT LITERAL  0.500000
FLOAT LITERAL  0.000000
FLOAT LITERAL  0.000000
SEMICOLON      ;




===[HIDDEN TESTS/bad20.bminor Input]===
// test comparotors and boolean logic
if (a | b)
{
	print " a || b is true";
}
if (a & b)// must had 2 &&
{
	print " a || b is true";
}

===[HIDDEN TESTS/bad20.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad20.bminor Output]===
COMMENT        // test comparotors and boolean logic

IF             if
LEFT PAREN     (
IDENTIFIER     a
ERROR          |




===[HIDDEN TESTS/bad21.bminor Input]===

"""


===[HIDDEN TESTS/bad21.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad21.bminor Output]===
STRING LITERAL 
ERROR          "




===[HIDDEN TESTS/bad22.bminor Input]===
"012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"


===[HIDDEN TESTS/bad22.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad22.bminor Output]===
ERROR          "




===[HIDDEN TESTS/bad23.bminor Input]===
$minus

===[HIDDEN TESTS/bad23.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad23.bminor Output]===
ERROR          $




===[HIDDEN TESTS/bad25.bminor Input]===
// invalid character
'😋'

===[HIDDEN TESTS/bad25.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad25.bminor Output]===
COMMENT        // invalid character

ERROR          '




===[HIDDEN TESTS/bad26.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[HIDDEN TESTS/bad26.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad26.bminor Output]===
COMMENT        /*
A string should not contain a literal newline,
but use backslash-n instead.
*/
ERROR          "




===[HIDDEN TESTS/bad27.bminor Input]===
'''

===[HIDDEN TESTS/bad27.bminor Status]===
return code: 0
TEST NOT PASSED

===[HIDDEN TESTS/bad27.bminor Output]===
CHAR LITERAL   ''' '




===[HIDDEN TESTS/bad28.bminor Input]===
"'"'"

===[HIDDEN TESTS/bad28.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad28.bminor Output]===
STRING LITERAL '
ERROR          '




===[HIDDEN TESTS/bad29.bminor Input]===
'\t\e\s\t\ \s\t\r\i\n\g'

===[HIDDEN TESTS/bad29.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad29.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad30.bminor Input]===
'\0x12\0x34'

===[HIDDEN TESTS/bad30.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad30.bminor Output]===
ERROR          '




===[HIDDEN TESTS/bad0.bminor Input]===
!@#$*(!&%!@)#(@!+)!@*!@)*$!@_)(%!@_%(*!

===[HIDDEN TESTS/bad0.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad0.bminor Output]===
NOT            !
ERROR          @




===== SUMMARIZED SCANNER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 11,
      "incorrect": 0
    },
    "Bad": {
      "correct": 11,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 15,
      "incorrect": 0
    },
    "Bad": {
      "correct": 26,
      "incorrect": 4
    }
  }
}
Scanner Project Grade
    ---------------------------------

    General Structure (35/35 points)
    ----------------------------------------------
    I like the comment headers above each function. That really helps keep the readability of your code high and will make it easier to come back to for later assignments

    Student Tests (20/20 points)
    ------------------------------------------
    Nice work providing two extra test cases!

    Hidden Tests (41/45 points)
    ------------------------------------------
    Looks like a couple tests had trouble with C style comments
    One test had an error on floating point scanning

    Coding Style (10/10 points)
    ------------------------------------------
    gen_tokens.c is pretty cool. Its a nice idea to abstract out functionality and this will be really easy and helpful to use when writing the parser.
